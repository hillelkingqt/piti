const TelegramBot = require('node-telegram-bot-api');
const { google } = require('googleapis');
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const mime = require('mime-types');
const moment = require('moment-timezone'); // *** ADDED for date/time handling ***
const express = require('express'); // ADD THIS
const adminApiRoutes = require('./adminApiRoutes'); // ADD THIS
const cors = require('cors'); // Will be installed

// --- Configuration ---
const TELEGRAM_BOT_TOKEN = '7876061979:AAF4qdcalkpseJq6buMrEMTJQsobYVUIH-4';
const GEMINI_API_KEY = 'AIzaSyCqQDiGTA-wX4Aggm-xxWATqTjO7tvW8W8'; // Use your actual Gemini API Key
const TARGET_CHAT_ID = 5610767655; // Your specific chat ID
const GEMINI_MODEL_NAME = 'gemini-2.0-flash-thinking-exp'; // *** Specific Model Name - UNCHANGED ***

const CREDENTIALS_PATH = path.join(__dirname, 'client_secret_170964452340-4a28usprg4v3ga2mua7rlgf3uvp3u8ns.apps.googleusercontent.com.json');
const TOKEN_PATH = path.join(__dirname, 'token.json');
const MEMORIES_PATH = path.join(__dirname, 'memories.json');
const LAST_HISTORY_ID_PATH = path.join(__dirname, 'lastHistoryId.txt');
const TEMP_FILES_DIR = path.join(__dirname, 'temp_telegram_files');

const GMAIL_CHECK_INTERVAL = 30000; // Check Gmail every 30 seconds
const HISTORY_LENGTH = 30;
const MAX_SEARCH_RESULTS = 20; // Max emails to return in a search
const ISRAEL_TIMEZONE = 'Asia/Jerusalem'; // *** ADDED for timezone ***

// --- Global Variables ---
let oAuth2Client;
let gmail;
/** @type {TelegramBot} */
let bot;
let chatHistory = {}; // Store history per chat { chatId: [messages] }
let recentSearchResults = {}; // Store recent search results per chat { chatId: results }
let memories = [];
let telegramFileMap = new Map(); // Map<telegramMessageId, {filePath, originalName, mimeType}>
let lastHistoryId;
let botInfo = null; // Store bot info like ID and username after connection

// --- Initialization ---

async function initialize() {
    console.log("üöÄ Initializing Bot...");
    moment.tz.setDefault(ISRAEL_TIMEZONE); // *** Set default timezone ***

    // Ensure temp directory exists
    if (!fs.existsSync(TEMP_FILES_DIR)) {
        fs.mkdirSync(TEMP_FILES_DIR);
        console.log(`Created temporary files directory: ${TEMP_FILES_DIR}`);
    }

    // Load Memories
    loadMemories();
    console.log(`üß† Loaded ${memories.length} initial memories.`);

    // Load Last History ID
    loadLastHistoryId();
    console.log(`üì® Initial Gmail History ID: ${lastHistoryId || 'None (will fetch)'}`);

    // Initialize Google Auth and Gmail API
    if (!initializeGoogleApis()) {
        console.error("‚ùå CRITICAL: Failed to initialize Google APIs. Exiting.");
        process.exit(1);
    }
    console.log("üîë Google APIs initialized.");

    // Initialize Telegram Bot
    bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

    try {
        botInfo = await bot.getMe(); // Get bot's own info
        console.log(`ü§ñ Telegram Bot connected: ${botInfo.first_name} (@${botInfo.username}, ID: ${botInfo.id})`);
    } catch (error) {
        console.error("‚ùå Failed to get bot info:", error);
        process.exit(1); // Exit if we can't verify bot connection
    }

    setupTelegramListeners(); // Sets up message listener AND error handlers

    // Start Gmail check loop
    console.log(`üìß Starting Gmail check loop (interval: ${GMAIL_CHECK_INTERVAL / 1000}s)...`);
    // Run the first check with a slight delay to allow bot connection to fully stabilize
    setTimeout(checkNewEmails, 5000);
    setInterval(checkNewEmails, GMAIL_CHECK_INTERVAL);

    console.log("‚úÖ Bot initialization complete. Waiting for messages and emails...");
}

// --- Google API Initialization (Same as before, includes token refresh) ---
function initializeGoogleApis() {
    try {
        const credentials = loadCredentials();
        if (!credentials) return false;
        oAuth2Client = authorize(credentials);
        if (!oAuth2Client) return false;
        gmail = google.gmail({ version: 'v1', auth: oAuth2Client });
        return true;
    } catch (error) {
        console.error('‚ùå Error initializing Google APIs:', error);
        return false;
    }
}

function loadCredentials() {
    try {
        const content = fs.readFileSync(CREDENTIALS_PATH);
        return JSON.parse(content);
    } catch (err) {
        console.error(`‚ùå Error loading credentials file (${CREDENTIALS_PATH}):`, err);
        return null;
    }
}

function authorize(credentials) {
    try {
        const { client_secret, client_id, redirect_uris } = credentials.installed;
        const client = new google.auth.OAuth2(client_id, client_secret, redirect_uris[0]);
        // Load token or throw error if it doesn't exist
        if (!fs.existsSync(TOKEN_PATH)) {
            throw new Error(`Token file not found at ${TOKEN_PATH}. Please authenticate first.`);
        }
        const token = JSON.parse(fs.readFileSync(TOKEN_PATH));
        client.setCredentials(token);

        client.on('tokens', (newTokens) => {
            const currentToken = client.credentials; // Get current token state
            let tokenToSave = {...currentToken}; // Clone it
            if (newTokens.refresh_token) {
                console.log('üîë Received new refresh token.');
                tokenToSave.refresh_token = newTokens.refresh_token;
            }
            if(newTokens.access_token){
                tokenToSave.access_token = newTokens.access_token;
            }
            if(newTokens.expiry_date){
                tokenToSave.expiry_date = newTokens.expiry_date;
            }

            try {
                fs.writeFileSync(TOKEN_PATH, JSON.stringify(tokenToSave, null, 2));
                console.log('üîë Token refreshed and saved successfully.');
                client.setCredentials(tokenToSave); // Update client immediately
            } catch (err) {
                console.error('‚ùå Error saving refreshed token:', err);
            }
        });
        return client;
    } catch (err) {
        console.error('‚ùå Error authorizing Google Client:', err);
        return null;
    }
}

// --- Memory Persistence (Same as before) ---
function loadMemories() {
    try {
        if (fs.existsSync(MEMORIES_PATH)) {
            const data = fs.readFileSync(MEMORIES_PATH, 'utf8');
            memories = JSON.parse(data);
            if (!Array.isArray(memories)) {
                console.warn("‚ö†Ô∏è Memories file exists but is not an array. Resetting to empty.");
                memories = [];
            }
            memories.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        } else {
            console.log("No memories file found, creating one.");
            memories = [];
            fs.writeFileSync(MEMORIES_PATH, JSON.stringify([]), 'utf8');
        }
    } catch (err) {
        console.error("‚ùå Error loading memories:", err);
        memories = [];
    }
}

function saveMemories() {
    try {
        if (!Array.isArray(memories)) {
            console.error("‚ùå Attempted to save non-array data to memories. Aborting.");
            return;
        }
        fs.writeFileSync(MEMORIES_PATH, JSON.stringify(memories, null, 2), 'utf8');
    } catch (err) {
        console.error("‚ùå Error saving memories:", err);
    }
}

// --- Gmail History Persistence (Same as before) ---
function loadLastHistoryId() {
    try {
        if (fs.existsSync(LAST_HISTORY_ID_PATH)) {
            lastHistoryId = fs.readFileSync(LAST_HISTORY_ID_PATH, 'utf8').trim();
            if (lastHistoryId === "") lastHistoryId = null; // Treat empty file as null
        } else {
            console.log("No last history ID file found, creating one.");
            lastHistoryId = null;
            fs.writeFileSync(LAST_HISTORY_ID_PATH, '', 'utf8');
        }
    } catch (err) {
        console.error("‚ùå Error loading last history ID:", err);
        lastHistoryId = null;
    }
}

function saveLastHistoryId(historyId) {
    if (!historyId) {
         console.warn("‚ö†Ô∏è Attempted to save null or empty history ID. Skipping.");
         return;
     }
    try {
        fs.writeFileSync(LAST_HISTORY_ID_PATH, historyId.toString(), 'utf8'); // Ensure it's a string
        lastHistoryId = historyId;
    } catch (err) {
        console.error("‚ùå Error saving last history ID:", err);
    }
}

// --- Bot Message Logging Wrapper ---
async function sendMessageAndLog(chatId, text, options = {}) {
    if (!bot) {
        console.error("‚ùå Attempted to send message before bot was initialized.");
        return null;
    }
    if (!botInfo) {
        try { botInfo = await bot.getMe(); } catch(e){ console.error("Failed to get bot info in send log"); return null;}
    }
    try {
        const sentMsg = await bot.sendMessage(chatId, text, options);
        if (sentMsg) {
            addToHistory(chatId, {
                message_id: sentMsg.message_id,
                from: { id: botInfo.id, first_name: botInfo.first_name, username: botInfo.username, is_bot: true },
                chat: { id: chatId },
                date: Math.floor(Date.now() / 1000),
                text: text
            });
        } else {
             console.warn("[sendMessageAndLog] bot.sendMessage did not return a message object. Cannot log to history.");
        }
        return sentMsg;
    } catch (error) {
        console.error(`‚ùå Error sending message or logging bot reply in chat ${chatId}:`, error.response?.data || error.message);
        // Log error message to history
        addToHistory(chatId, {
             message_id: Date.now(), // Fake ID for logging
             from: { id: botInfo?.id || -1, first_name: botInfo?.first_name || 'Bot', is_bot: true },
             chat: { id: chatId },
             date: Math.floor(Date.now() / 1000),
             text: `[BOT_SEND_ERROR: ${error.message}]`
         });
        // Don't re-throw here, let the calling function decide based on context
        // throw error;
        return null; // Indicate failure
    }
}


// --- Gmail Fetching Logic (Same as before, handles token refresh) ---
async function checkNewEmails() {
    if (!gmail || !oAuth2Client) {
        console.warn("‚è≥ Gmail client not ready, skipping check.");
        return;
    }
     if (!oAuth2Client.credentials || !oAuth2Client.credentials.access_token) {
         console.warn("‚è≥ Missing Google credentials/token, skipping Gmail check.");
         if(oAuth2Client.credentials.refresh_token){
             try {
                 console.log("Attempting token refresh before Gmail check...");
                 await oAuth2Client.refreshAccessToken();
                 console.log("Token refreshed successfully.");
             } catch (refreshError) {
                 console.error("‚ùå Token refresh failed:", refreshError.message);
                 return; // Don't proceed if refresh fails
             }
         } else {
             console.error("‚ùå No refresh token available. Manual re-authentication needed.");
             return;
         }
     }

     if (!lastHistoryId) {
         try {
             console.log("‚è≥ No last history ID. Fetching latest message ID...");
             const res = await gmail.users.messages.list({ userId: 'me', maxResults: 1 });
             if (res.data.messages && res.data.messages.length > 0 && res.data.historyId) {
                 console.log(`üìö Established starting history ID: ${res.data.historyId}`);
                 saveLastHistoryId(res.data.historyId);
             } else if (res.data.messages && res.data.messages.length > 0) {
                 const latestMsgId = res.data.messages[0].id;
                 const msgDetails = await gmail.users.messages.get({ userId: 'me', id: latestMsgId, format: 'metadata', metadataHeaders: ['historyId'] });
                 if (msgDetails.data.historyId) {
                      console.log(`üìö Found starting history ID from message: ${msgDetails.data.historyId}`);
                     saveLastHistoryId(msgDetails.data.historyId);
                 } else {
                     console.error("‚ùå Could not retrieve history ID from the latest message or list call.");
                     return;
                 }
             } else {
                 console.log("üì¨ Inbox seems empty. No history ID baseline set yet.");
                  if (res.data.historyId) {
                      saveLastHistoryId(res.data.historyId);
                  }
                  return;
             }
         } catch (err) {
             console.error("‚ùå Error getting initial history ID:", err.response?.data?.error?.message || err.message);
              if (err.response?.status === 401 || err.response?.data?.error === 'invalid_grant') {
                  console.error("Authentication error fetching initial history ID. Token might be invalid/expired.");
              }
             return;
         }
     }

    try {
        const response = await gmail.users.history.list({
            userId: 'me',
            startHistoryId: lastHistoryId,
            historyTypes: ['messageAdded'],
        });

         let currentHistoryId = response.data.historyId;

        if (response.data.history) {
            const addedMessages = response.data.history
                .flatMap(record => record.messagesAdded || [])
                 .map(added => added.message)
                 .filter(msg => !msg.labelIds || (!msg.labelIds.includes('DRAFT') && !msg.labelIds.includes('SENT') ) || msg.labelIds.includes('INBOX') || msg.labelIds.includes('UNREAD'))
                 .filter((msg, index, self) => self.findIndex(m => m.id === msg.id) === index);

            if (addedMessages.length > 0) {
                console.log(`üíå Found ${addedMessages.length} potentially new message(s). Processing...`);
                for (const message of addedMessages) {
                    await processGmailMessage(message.id);
                    await delay(600);
                }
            }
        }

         if (currentHistoryId && currentHistoryId !== lastHistoryId) { // Only save if it changed
              saveLastHistoryId(currentHistoryId);
         }

    } catch (error) {
        console.error("‚ùå Error checking Gmail history:", error.response?.data?.error?.message || error.message);
         if (error.response?.status === 401 || error.response?.data?.error === 'invalid_grant') {
             console.error("Authentication error during Gmail check. Token invalid/expired.");
         } else if (error.response?.status === 404 && error.response?.data?.error?.message?.includes('historyId not found') ) {
             console.warn(`‚ö†Ô∏è History ID ${lastHistoryId} not found or too old. Resetting history ID.`);
             saveLastHistoryId(null);
             loadLastHistoryId();
         }
    }
}

async function processGmailMessage(messageId) {
    console.log(`üìß Processing Gmail message ID: ${messageId}`);
    try {
        const msg = await gmail.users.messages.get({
            userId: 'me',
            id: messageId,
            format: 'full' // Need full format for body/attachments
        });

        if (msg.data.labelIds && (msg.data.labelIds.includes('SENT') || msg.data.labelIds.includes('DRAFT')) && !msg.data.labelIds.includes('INBOX') ) {
             console.log(`üö´ Skipping message ID ${messageId} as it appears to be SENT/DRAFT only.`);
             return;
        }

        const payload = msg.data.payload;
        if(!payload) {
             console.warn(`‚ö†Ô∏è No payload found for message ID ${messageId}. Skipping.`);
             return;
         }
        const headers = payload.headers;
        if (!headers) {
             console.warn(`‚ö†Ô∏è No headers found for message ID ${messageId}. Skipping.`);
             return;
         }
        const subjectHeader = headers.find(header => header.name.toLowerCase() === 'subject');
        const fromHeader = headers.find(header => header.name.toLowerCase() === 'from');

        const subject = subjectHeader ? subjectHeader.value : 'No Subject';
        const sender = fromHeader ? fromHeader.value : 'Unknown Sender';
        const originalGmailId = msg.data.id;

        let body = extractTextBody(payload); // Use helper function

        // Crude HTML simplification if only HTML was found
        if (!body && payload.mimeType === 'text/html' && payload.body?.data) {
           const htmlBody = Buffer.from(payload.body.data, 'base64').toString('utf8');
           body = `(◊™◊¶◊ï◊í◊î ◊§◊©◊ï◊ò◊î ◊©◊ú ◊™◊ï◊õ◊ü HTML):\n${stripHtmlTags(htmlBody).substring(0, 3000)}...`;
        } else if (!body) {
            body = extractHtmlBody(payload); // Try extracting HTML if plain text failed
            if(body) {
                 body = `(◊™◊¶◊ï◊í◊î ◊§◊©◊ï◊ò◊î ◊©◊ú ◊™◊ï◊õ◊ü HTML):\n${stripHtmlTags(body).substring(0, 3000)}...`;
            } else {
                body = 'Email body not found or could not be decoded.';
            }
        }


        let telegramMessage = `üì¨ *◊î◊ï◊ì◊¢◊™ ◊ì◊ï◊ê"◊ú ◊ó◊ì◊©◊î ◊î◊™◊ß◊ë◊ú◊î* üì¨\n\n`;
        telegramMessage += `*◊û◊ê◊™:* \`${sender}\`\n`;
        telegramMessage += `*◊†◊ï◊©◊ê:* ${subject}\n`;
        telegramMessage += `*◊û◊ñ◊î◊î ◊ì◊ï◊ê"◊ú (◊ú◊û◊¢◊†◊î/◊ó◊ô◊§◊ï◊©):* \`${originalGmailId}\`\n\n`; // Use backticks
        telegramMessage += `------------------\n`;
        telegramMessage += body.substring(0, 3500);
        if (body.length > 3500) {
            telegramMessage += "\n\n_[◊î◊ï◊ì◊¢◊î ◊ß◊ï◊¶◊®◊î]_";
        }

        // --- Check for Attachments and list them ---
        const attachments = findAttachments(payload);
        if (attachments.length > 0) {
            telegramMessage += `\n\nüìé *◊ß◊ë◊¶◊ô◊ù ◊û◊¶◊ï◊®◊§◊ô◊ù:*\n`;
            attachments.forEach(att => {
                telegramMessage += `- ${att.filename} (${formatBytes(att.size)})\n`;
                // Note: We don't expose attachment IDs here for simplicity,
                // they will be handled during specific forwarding requests via search.
            });
        }
        // --- End Attachment Check ---

        console.log(`‚úÖ Forwarding Email ID: ${originalGmailId}, Subject: ${subject}`);
        await sendMessageAndLog(TARGET_CHAT_ID, telegramMessage, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error(`‚ùå Error processing Gmail message ID ${messageId}:`, error.response?.data || error.message);
        try {
           await sendMessageAndLog(TARGET_CHAT_ID, `‚ùå ◊©◊í◊ô◊ê◊î ◊ë◊¢◊ô◊ë◊ï◊ì ◊ì◊ï◊ê"◊ú ◊¢◊ù ◊û◊ñ◊î◊î \`${messageId}\`.\n\`\`\`${error.message}\`\`\``, { parse_mode: 'Markdown' });
        } catch (notifyError) {
            console.error("‚ùå Additionally failed to send processing error notification to Telegram:", notifyError);
        }
    }
}

// --- Telegram Bot Logic ---

function setupTelegramListeners() {
    console.log("Setting up Telegram listeners...");

    bot.on('message', async (msg) => {
        const chatId = msg.chat.id;
        const userId = msg.from.id;
        const messageId = msg.message_id;

        if (!botInfo || !botInfo.id) {
            console.error("‚ùå Cannot process message: Bot info not available yet.");
             try { botInfo = await bot.getMe(); } catch (e) { console.error("Failed to get bot info on retry:", e); return; }
             if (!botInfo) return;
        }

        if (chatId !== TARGET_CHAT_ID || userId === botInfo.id) {
            return; // Ignore messages not from target chat or from the bot itself
        }

        console.log(`üì© Received message ${messageId} from target chat ${chatId} (User: ${userId})`);

        // --- Add incoming USER message to History ---
        addToHistory(chatId, msg);
        // --- Clear previous search results for this chat when user sends a new message ---
        delete recentSearchResults[chatId];

        // --- Handle File Uploads ---
        let fileInfoForPrompt = null;
        if (msg.document || msg.photo || msg.audio || msg.video || msg.voice) {
            try {
                const fileSource = msg.document || (msg.photo ? msg.photo[msg.photo.length - 1] : null) || msg.audio || msg.video || msg.voice;
                if (fileSource) {
                    const fileId = fileSource.file_id;
                    const mimeType = fileSource.mime_type || mime.lookup(msg.document?.file_name || '') || 'application/octet-stream';
                    const originalName = msg.document?.file_name || `photo_${messageId}.${mime.extension(mimeType) || 'jpg'}` || `audio_${messageId}.${mime.extension(mimeType) || 'ogg'}` || `video_${messageId}.${mime.extension(mimeType) || 'mp4'}` || `voice_${messageId}.${mime.extension(mimeType) || 'ogg'}` || `file_${messageId}.${mime.extension(mimeType) || 'bin'}`;

                    console.log(`Downloading file ${originalName} (ID: ${fileId})...`);
                    fs.mkdirSync(TEMP_FILES_DIR, { recursive: true });
                    const downloadedPath = await bot.downloadFile(fileId, TEMP_FILES_DIR);

                    telegramFileMap.set(messageId, { filePath: downloadedPath, originalName, mimeType });
                    fileInfoForPrompt = {
                        telegramMessageId: messageId,
                        filename: originalName,
                        mimeType: mimeType
                    };
                    console.log(`üìÑ File received & saved: ${originalName} -> ${downloadedPath}, Mapped to Msg ID: ${messageId}`);
                }
            } catch (downloadError) {
                console.error(`‚ùå Error downloading/processing Telegram file for msg ${messageId}:`, downloadError);
                await sendMessageAndLog(chatId, "‚ö†Ô∏è ◊°◊ú◊ô◊ó◊î, ◊î◊ô◊™◊î ◊©◊í◊ô◊ê◊î ◊ë◊î◊ï◊®◊ì◊™ ◊î◊ß◊ï◊ë◊• ◊©◊©◊ú◊ó◊™.");
                fileInfoForPrompt = { error: `Failed to download/process file: ${downloadError.message}` };
            }
        }

        // --- Extract Reply Context ---
        let replyToTextForPrompt = null;
        let replyToMsgIdForPrompt = null;
         if (msg.reply_to_message) {
            const repliedMsg = msg.reply_to_message;
             replyToMsgIdForPrompt = repliedMsg.message_id;
            let senderName = 'Unknown User';
             let senderId = repliedMsg.from?.id;
             if(senderId === botInfo.id){
                 senderName = "◊ê◊†◊ô (◊î◊ë◊ï◊ò)";
             } else if (repliedMsg.from){
                  senderName = repliedMsg.from.first_name || repliedMsg.from.username || `User_${senderId}`;
             }
             replyToTextForPrompt = `[◊û◊ê◊™: ${senderName} - ID: ${replyToMsgIdForPrompt}] ${repliedMsg.text || ''}`;
             if (repliedMsg.caption) replyToTextForPrompt += ` [◊õ◊ô◊™◊ï◊ë: ${repliedMsg.caption}]`;
             if (repliedMsg.document) replyToTextForPrompt += ` [◊û◊°◊û◊ö: ${repliedMsg.document.file_name || '◊ß◊ï◊ë◊•'}]`;
             else if (repliedMsg.photo) replyToTextForPrompt += ` [◊™◊û◊ï◊†◊î]`;
             else if (repliedMsg.audio) replyToTextForPrompt += ` [◊©◊û◊¢]`;
             else if (repliedMsg.video) replyToTextForPrompt += ` [◊ï◊ô◊ì◊ê◊ï]`;
             else if (repliedMsg.voice) replyToTextForPrompt += ` [◊î◊ï◊ì◊¢◊î ◊ß◊ï◊ú◊ô◊™]`;
              console.log(`‚Ü©Ô∏è User replied to message ID: ${replyToMsgIdForPrompt}`);
        }

        // --- Prepare Context for Gemini ---
        const historyText = getChatHistory(chatId);
        const memoriesText = formatMemoriesForPrompt();
        const searchResultsText = formatSearchResultsForPrompt(chatId); // *** ADDED ***
        const currentTimeText = moment().format('LLLL'); // *** ADDED (e.g., Tuesday, July 9, 2024 3:54 PM) ***

        // --- Construct Gemini Prompt (HEBREW INSTRUCTIONS - UPDATED) ---
        const geminiPrompt = `
◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ï◊ô◊®◊ò◊ï◊ê◊ú◊ô ◊î◊û◊ï◊ò◊û◊¢ ◊ë◊ò◊ú◊í◊®◊ù, ◊ï◊û◊ó◊ï◊ë◊® ◊ú◊ó◊©◊ë◊ï◊ü ◊î-Gmail ◊©◊ú ◊î◊û◊©◊™◊û◊©. ◊©◊û◊ö "◊ë◊ï◊ò Gmail".
**◊ó◊ï◊ë◊î ◊ú◊¢◊†◊ï◊™ ◊ê◊ö ◊ï◊®◊ß ◊ë◊§◊ï◊®◊û◊ò JSON ◊™◊ß◊†◊ô. ◊ê◊ô◊ü ◊ú◊î◊ï◊°◊ô◊£ ◊ò◊ß◊°◊ò ◊ú◊§◊†◊ô ◊ê◊ï ◊ê◊ó◊®◊ô ◊ê◊ï◊ë◊ô◊ô◊ß◊ò ◊î-JSON.**
◊ê◊°◊ï◊® ◊ú◊î◊©◊™◊û◊© ◊ë-markdown (\`\`\`) ◊°◊ë◊ô◊ë ◊î-JSON.

◊î◊™◊ê◊®◊ô◊ö ◊ï◊î◊©◊¢◊î ◊î◊†◊ï◊õ◊ó◊ô◊ô◊ù (◊©◊¢◊ï◊ü ◊ô◊©◊®◊ê◊ú): ${currentTimeText}

◊î◊§◊¢◊ï◊ú◊ï◊™ ◊î◊ñ◊û◊ô◊†◊ï◊™ (◊¶◊ô◊ô◊ü ◊ê◊ó◊™ ◊ë◊©◊ì◊î "action"):

1.  **"text"**: ◊©◊ú◊ô◊ó◊™ ◊î◊ï◊ì◊¢◊™ ◊ò◊ß◊°◊ò ◊§◊©◊ï◊ò◊î ◊ú◊û◊©◊™◊û◊©.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "text"
    - "message": "◊™◊ï◊õ◊ü ◊î◊™◊í◊ï◊ë◊î ◊©◊ú◊ö ◊ë◊¢◊ë◊®◊ô◊™."
    - "replyToTelegramMessageId": <◊û◊°◊§◊®> (◊î-message_id ◊©◊ú ◊î◊ï◊ì◊¢◊™ ◊î◊û◊©◊™◊û◊© ◊©◊¢◊ú◊ô◊î ◊ê◊™◊î ◊û◊í◊ô◊ë)

2.  **"send_email"**: ◊©◊ú◊ô◊ó◊™ ◊ì◊ï◊ê"◊ú ◊ó◊ì◊© ◊û◊ó◊©◊ë◊ï◊ü ◊î-Gmail ◊©◊ú ◊î◊û◊©◊™◊û◊©.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "send_email"
    - "to": "recipient@example.com"
    - "subject": "◊†◊ï◊©◊ê ◊î◊ì◊ï◊ê""◊ú"
    - "body": "◊í◊ï◊£ ◊î◊î◊ï◊ì◊¢◊î (◊ò◊ß◊°◊ò ◊§◊©◊ï◊ò ◊û◊ï◊û◊ú◊•)."
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>
    ◊©◊ì◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ô◊ù:
    - "attachmentTelegramMessageId": <◊û◊°◊§◊®> (◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊ë◊ô◊ß◊© ◊ú◊¶◊®◊£ ◊ß◊ï◊ë◊• ◊©◊©◊ú◊ó ◊ë◊ò◊ú◊í◊®◊ù, ◊°◊§◊ß ◊ê◊™ ◊î-message_id ◊©◊ú ◊î◊î◊ï◊ì◊¢◊î ◊¢◊ù ◊î◊ß◊ï◊ë◊•. ◊¢◊ô◊ô◊ü ◊ë'◊§◊®◊ò◊ô ◊î◊ß◊ï◊ë◊•' ◊ú◊û◊ò◊î.)
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ë◊ô◊†◊ô◊ô◊ù ◊ú◊û◊©◊™◊û◊© ◊ë◊ò◊ú◊í◊®◊ù (◊ú◊ì◊ï◊í◊û◊î: '◊©◊ï◊ú◊ó ◊ê◊™ ◊î◊û◊ô◊ô◊ú...')", ◊™◊ô◊©◊ú◊ó ◊ú◊§◊†◊ô ◊†◊ô◊°◊ô◊ï◊ü ◊î◊©◊ú◊ô◊ó◊î.

3.  **"reply_email"**: ◊û◊¢◊†◊î ◊ú◊ì◊ï◊ê"◊ú ◊ß◊ô◊ô◊ù ◊ë-Gmail (◊©◊î◊ë◊ï◊ò ◊î◊¢◊ë◊ô◊® ◊ß◊ï◊ì◊ù).
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "reply_email"
    - "gmailMessageId": "string" (◊û◊ñ◊î◊î ◊î◊ì◊ï◊ê"◊ú ◊î◊û◊ß◊ï◊®◊ô ◊ë-Gmail, ◊©◊î◊ë◊ï◊ò ◊°◊ô◊§◊ß ◊ë◊î◊ï◊ì◊¢◊î ◊î◊û◊ß◊ï◊®◊ô◊™)
    - "subject": "RE: [◊†◊ï◊©◊ê ◊û◊ß◊ï◊®◊ô]" // ◊ê◊ï ◊†◊ï◊©◊ê ◊ó◊ì◊© ◊ê◊ù ◊û◊™◊ê◊ô◊ù
    - "body": "◊™◊ï◊õ◊ü ◊î◊û◊¢◊†◊î ◊©◊ú◊ö."
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>
    ◊©◊ì◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ô◊ù:
    - "attachmentTelegramMessageId": <◊û◊°◊§◊®> (◊õ◊û◊ï ◊ë-send_email)
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ë◊ô◊†◊ô◊ô◊ù ◊ú◊û◊©◊™◊û◊© ◊ë◊ò◊ú◊í◊®◊ù (◊ú◊ì◊ï◊í◊û◊î: '◊û◊†◊°◊î ◊ú◊©◊ú◊ï◊ó ◊™◊©◊ï◊ë◊î ◊ú◊û◊ô◊ô◊ú...')", ◊™◊ô◊©◊ú◊ó ◊ú◊§◊†◊ô ◊†◊ô◊°◊ô◊ï◊ü ◊î◊©◊ú◊ô◊ó◊î.

4.  **"add_memory"**: ◊î◊ï◊°◊§◊™ ◊§◊®◊ò ◊û◊ô◊ì◊¢ ◊ú◊ñ◊ô◊õ◊®◊ï◊ü ◊î◊û◊™◊û◊©◊ö.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "add_memory"
    - "memoryData": { "info": "◊î◊ò◊ß◊°◊ò ◊©◊ô◊© ◊ú◊ñ◊õ◊ï◊®", "person": "(◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô) ◊¢◊ú ◊û◊ô ◊î◊û◊ô◊ì◊¢?", "type": "(◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô) ◊°◊ï◊í: ◊¢◊ï◊ë◊ì◊î/◊î◊¢◊ì◊§◊î ◊ï◊õ◊ï'." }
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ê◊ô◊©◊ï◊® ◊ú◊û◊©◊™◊û◊© ◊ë◊¢◊ë◊®◊ô◊™ (◊ú◊ì◊ï◊í◊û◊î: '◊ë◊°◊ì◊®, ◊ê◊ñ◊õ◊ï◊® ◊ñ◊ê◊™.')"
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>

5.  **"delete_memory"**: ◊û◊ó◊ô◊ß◊™ ◊ñ◊ô◊õ◊®◊ï◊ü ◊°◊§◊¶◊ô◊§◊ô ◊ú◊§◊ô ◊î◊û◊ñ◊î◊î (ID) ◊©◊ú◊ï.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "delete_memory"
    - "memoryIdToDelete": <◊û◊°◊§◊®> (◊î◊û◊ñ◊î◊î ◊î◊ô◊ô◊ó◊ï◊ì◊ô ◊©◊ú ◊î◊ñ◊ô◊õ◊®◊ï◊ü ◊ú◊û◊ó◊ô◊ß◊î - ◊®◊ê◊î '◊ñ◊ô◊õ◊®◊ï◊†◊ï◊™ ◊†◊ï◊õ◊ó◊ô◊ô◊ù' ◊ú◊û◊ò◊î)
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ê◊ô◊©◊ï◊®/◊©◊í◊ô◊ê◊î ◊ú◊û◊©◊™◊û◊© (◊ú◊ì◊ï◊í◊û◊î: '◊î◊ñ◊ô◊õ◊®◊ï◊ü ◊†◊û◊ó◊ß.', '◊û◊ñ◊î◊î ◊ñ◊ô◊õ◊®◊ï◊ü ◊ú◊ê ◊†◊û◊¶◊ê.')"
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>

6.  **"search_email"**: ◊ó◊ô◊§◊ï◊© ◊î◊ï◊ì◊¢◊ï◊™ ◊ì◊ï◊ê"◊ú ◊ë◊ó◊©◊ë◊ï◊ü ◊î-Gmail ◊©◊ú ◊î◊û◊©◊™◊û◊©.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "search_email"
    - "query": "string" (◊©◊ê◊ô◊ú◊™◊™ ◊î◊ó◊ô◊§◊ï◊©. ◊ú◊ì◊ï◊í◊û◊î: "◊ó◊©◊ë◊ï◊†◊ô◊™ PDF", "from:client@example.com subject:◊ì◊ó◊ï◊£", "has:attachment filename:report.docx"). ◊™◊û◊ï◊ö ◊ë◊ê◊ï◊§◊®◊ò◊ï◊®◊ô◊ù ◊°◊ò◊†◊ì◊®◊ò◊ô◊ô◊ù ◊©◊ú Gmail.
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>
    ◊©◊ì◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ô◊ù:
    - "searchPeriod": "string" (◊¶◊ô◊ï◊ü ◊™◊ß◊ï◊§◊™ ◊ñ◊û◊ü. ◊ì◊ï◊í◊û◊ê◊ï◊™: "today", "yesterday", "last_7_days", "YYYY-MM-DD", "after:YYYY-MM-DD before:YYYY-MM-DD"). ◊ê◊ù ◊ñ◊î ◊î◊©◊ì◊î *◊î◊ô◊ó◊ô◊ì* ◊ú◊°◊ô◊†◊ï◊ü (◊ú◊ú◊ê query), ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊ô◊ô◊©◊ú◊ó◊ï ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊û◊©◊™◊û◊©. ◊ê◊ó◊®◊™, ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊ô◊ï◊ó◊ñ◊®◊ï ◊ê◊ú◊ô◊ö ◊ú◊î◊û◊©◊ö ◊¢◊ô◊ë◊ï◊ì.
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ë◊ô◊†◊ô◊ô◊ù ◊ú◊û◊©◊™◊û◊© (◊ú◊ì◊ï◊í◊û◊î: '◊û◊ó◊§◊© ◊ë◊û◊ô◊ô◊ú◊ô◊ù...')", ◊™◊ô◊©◊ú◊ó ◊ú◊§◊†◊ô ◊î◊ó◊ô◊§◊ï◊©.

7.  **"forward_email_from_search"**: ◊î◊¢◊ë◊®◊™ ◊™◊ï◊õ◊ü (◊°◊ô◊õ◊ï◊ù) ◊©◊ú ◊ì◊ï◊ê"◊ú ◊©◊†◊û◊¶◊ê ◊ë◊ó◊ô◊§◊ï◊© ◊ú◊û◊©◊™◊û◊© ◊ë◊ò◊ú◊í◊®◊ù.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "forward_email_from_search"
    - "searchResultGmailId": "string" (◊û◊ñ◊î◊î ◊î-Gmail ◊©◊ú ◊î◊î◊ï◊ì◊¢◊î ◊û◊î◊ó◊ô◊§◊ï◊© ◊î◊ê◊ó◊®◊ï◊ü - ◊®◊ê◊î '◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ó◊®◊ï◊†◊ï◊™')
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>
    ◊©◊ì◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ô◊ù:
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ë◊ô◊†◊ô◊ô◊ù ◊ú◊û◊©◊™◊û◊© (◊ú◊ì◊ï◊í◊û◊î: '◊û◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊û◊ô◊ô◊ú...')", ◊™◊ô◊©◊ú◊ó ◊ú◊§◊†◊ô ◊î◊î◊¢◊ë◊®◊î.

8.  **"forward_attachment_from_search"**: ◊î◊¢◊ë◊®◊™ ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ◊°◊§◊¶◊ô◊§◊ô ◊û◊ì◊ï◊ê"◊ú ◊©◊†◊û◊¶◊ê ◊ë◊ó◊ô◊§◊ï◊© ◊ú◊û◊©◊™◊û◊© ◊ë◊ò◊ú◊í◊®◊ù.
    ◊©◊ì◊ï◊™ JSON ◊†◊ì◊®◊©◊ô◊ù:
    - "action": "forward_attachment_from_search"
    - "searchResultGmailId": "string" (◊û◊ñ◊î◊î ◊î-Gmail ◊©◊ú ◊î◊î◊ï◊ì◊¢◊î ◊û◊î◊ó◊ô◊§◊ï◊© ◊î◊ê◊ó◊®◊ï◊ü)
    - "attachmentInfo": { "filename": "string", "partId": "string", "attachmentId": "string" } (◊§◊®◊ò◊ô ◊î◊ß◊ï◊ë◊• ◊î◊û◊¶◊ï◊®◊£ ◊õ◊§◊ô ◊©◊î◊ï◊§◊ô◊¢◊ï ◊ë◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊î◊ê◊ó◊®◊ï◊†◊ï◊™)
    - "replyToTelegramMessageId": <◊û◊°◊§◊®>
    ◊©◊ì◊ï◊™ ◊ê◊ï◊§◊¶◊ô◊ï◊†◊ú◊ô◊ô◊ù:
    - "message": "◊î◊ï◊ì◊¢◊™ ◊ë◊ô◊†◊ô◊ô◊ù ◊ú◊û◊©◊™◊û◊© (◊ú◊ì◊ï◊í◊û◊î: '◊û◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊ß◊ï◊ë◊•...')", ◊™◊ô◊©◊ú◊ó ◊ú◊§◊†◊ô ◊î◊î◊¢◊ë◊®◊î.

◊û◊¢◊†◊î ◊û◊®◊ï◊ë◊î ◊§◊¢◊ï◊ú◊ï◊™:
◊†◊ô◊™◊ü ◊ú◊î◊ó◊ñ◊ô◊® ◊û◊¢◊®◊ö ◊©◊ú ◊ê◊ï◊ë◊ô◊ô◊ß◊ò◊ô ◊§◊¢◊ï◊ú◊î ◊ë◊©◊ì◊î "replies" ◊ë◊®◊û◊î ◊î◊¢◊ú◊ô◊ï◊†◊î ◊ê◊ù ◊†◊ì◊®◊©◊ï◊™ ◊û◊°◊§◊® ◊§◊¢◊ï◊ú◊ï◊™ ◊†◊§◊®◊ì◊ï◊™. ◊ê◊ù ◊ê◊™◊î ◊û◊©◊™◊û◊© ◊ë-"replies", ◊ê◊ú ◊™◊õ◊ú◊ï◊ú "action" ◊ë◊®◊û◊î ◊î◊¢◊ú◊ô◊ï◊†◊î.

--- ◊î◊ß◊©◊® ---

◊ñ◊ô◊õ◊®◊ï◊†◊ï◊™ ◊†◊ï◊õ◊ó◊ô◊ô◊ù (ID | ◊™◊ê◊®◊ô◊ö | ◊§◊®◊ò◊ô◊ù):
${memoriesText || "◊ê◊ô◊ü ◊ñ◊ô◊õ◊®◊ï◊†◊ï◊™ ◊©◊û◊ï◊®◊ô◊ù."}
---
${searchResultsText}
---
◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊î◊©◊ô◊ó◊î (${HISTORY_LENGTH} ◊î◊ï◊ì◊¢◊ï◊™ ◊ê◊ó◊®◊ï◊†◊ï◊™):
${historyText}
---
${replyToTextForPrompt ? `◊î◊ï◊ì◊¢◊î ◊©◊¶◊ï◊ò◊ò◊î (◊î◊û◊©◊™◊û◊© ◊¢◊†◊î ◊ú◊î):\n${replyToTextForPrompt}\n---` : ''}
${fileInfoForPrompt?.error ? `◊©◊í◊ô◊ê◊™ ◊ß◊ï◊ë◊•: ${fileInfoForPrompt.error}\n---` : (fileInfoForPrompt ? `◊§◊®◊ò◊ô ◊î◊ß◊ï◊ë◊• ◊©◊î◊û◊©◊™◊û◊© ◊©◊ú◊ó ◊ë◊î◊ï◊ì◊¢◊î ◊ñ◊ï (ID: ${fileInfoForPrompt.telegramMessageId}):\n◊©◊ù ◊ß◊ï◊ë◊•: ${fileInfoForPrompt.filename}\n◊°◊ï◊í: ${fileInfoForPrompt.mimeType}\n(◊†◊ô◊™◊ü ◊ú◊î◊™◊ô◊ô◊ó◊° ◊ú◊û◊ñ◊î◊î ◊î◊î◊ï◊ì◊¢◊î ${fileInfoForPrompt.telegramMessageId} ◊ë◊©◊ì◊î 'attachmentTelegramMessageId' ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊ô◊ë◊ß◊© ◊ú◊¶◊®◊§◊ï ◊ú◊û◊ô◊ô◊ú ◊ó◊ì◊©/◊û◊¢◊†◊î)\n---` : '')}
◊î◊ï◊ì◊¢◊™ ◊î◊û◊©◊™◊û◊© ◊î◊†◊ï◊õ◊ó◊ô◊™ (ID: ${messageId}):
${msg.text || '[◊ê◊ô◊ü ◊ò◊ß◊°◊ò ◊ë◊î◊ï◊ì◊¢◊î]'}

--- ◊î◊ï◊®◊ê◊ï◊™ ---
◊†◊™◊ó ◊ê◊™ ◊î◊ï◊ì◊¢◊™ ◊î◊û◊©◊™◊û◊© ◊î◊†◊ï◊õ◊ó◊ô◊™ ◊ë◊î◊ß◊©◊® ◊©◊ú ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊î◊©◊ô◊ó◊î, ◊î◊ñ◊ô◊õ◊®◊ï◊†◊ï◊™, ◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊î◊ê◊ó◊®◊ï◊†◊ï◊™ (◊ê◊ù ◊ß◊ô◊ô◊û◊ï◊™), ◊î◊î◊ï◊ì◊¢◊î ◊î◊û◊¶◊ï◊ò◊ò◊™ (◊ê◊ù ◊ß◊ô◊ô◊û◊™) ◊ï◊î◊ß◊ï◊ë◊• ◊©◊¶◊ï◊®◊£ (◊ê◊ù ◊ß◊ô◊ô◊ù). ◊¶◊ï◊® ◊™◊í◊ï◊ë◊™ JSON ◊™◊ß◊†◊ô◊™ ◊î◊û◊õ◊ô◊ú◊î ◊ê◊™ ◊î◊§◊¢◊ï◊ú◊î ◊î◊û◊™◊ê◊ô◊û◊î ◊ï◊ê◊™ ◊î◊©◊ì◊ï◊™ ◊î◊†◊ì◊®◊©◊ô◊ù.
- ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊û◊ë◊ß◊© ◊ú◊ó◊§◊© ◊û◊ô◊ô◊ú◊ô◊ù (◊ú◊û◊©◊ú ◊ú◊§◊ô ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó, ◊©◊ï◊ú◊ó, ◊†◊ï◊©◊ê), ◊î◊©◊™◊û◊© ◊ë◊§◊¢◊ï◊ú◊î **"search_email"**. ◊ê◊ù ◊î◊ë◊ß◊©◊î ◊õ◊ï◊ú◊ú◊™ ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó, ◊ê◊†◊ô (◊î◊ë◊ï◊ò) ◊ê◊ß◊ë◊ú ◊ê◊™ ◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊ë◊î◊ß◊©◊® ◊î◊ë◊ê ◊ï◊ê◊ñ ◊™◊ï◊õ◊ú ◊ú◊î◊ó◊ú◊ô◊ò ◊û◊î ◊ú◊¢◊©◊ï◊™ ◊ê◊ô◊™◊ü (◊ú◊°◊õ◊ù, ◊ú◊î◊¶◊ô◊¢ ◊î◊¢◊ë◊®◊î ◊ï◊õ◊ï'). ◊ê◊ù ◊î◊ó◊ô◊§◊ï◊© ◊î◊ï◊ê *◊®◊ß* ◊ú◊§◊ô ◊™◊ê◊®◊ô◊ö/◊ò◊ï◊ï◊ó ◊™◊ê◊®◊ô◊õ◊ô◊ù (◊ú◊ú◊ê ◊û◊ô◊ú◊ï◊™ ◊û◊§◊™◊ó ◊†◊ï◊°◊§◊ï◊™), ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊ô◊ô◊©◊ú◊ó◊ï ◊ô◊©◊ô◊®◊ï◊™ ◊ú◊û◊©◊™◊û◊©.
- ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊û◊ë◊ß◊© ◊ú◊î◊¢◊ë◊ô◊® ◊û◊ô◊ô◊ú ◊ê◊ï ◊ß◊ï◊ë◊• ◊û◊™◊ï◊ö ◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊©◊î◊ï◊¶◊í◊ï ◊ú◊ö, ◊î◊©◊™◊û◊© ◊ë◊§◊¢◊ï◊ú◊ï◊™ **"forward_email_from_search"** ◊ê◊ï **"forward_attachment_from_search"** ◊ë◊î◊™◊ê◊û◊î, ◊™◊ï◊ö ◊©◊ô◊û◊ï◊© ◊ë-\`searchResultGmailId\` ◊ï◊ë◊§◊®◊ò◊ô ◊î◊ß◊ï◊ë◊• ◊î◊û◊¶◊ï◊®◊£ ◊û◊™◊ï◊ö '◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ó◊®◊ï◊†◊ï◊™'.
- ◊ï◊ì◊ê ◊©◊î◊©◊ì◊î "replyToTelegramMessageId" ◊™◊û◊ô◊ì ◊û◊õ◊ô◊ú ◊ê◊™ ◊î◊û◊ñ◊î◊î ◊©◊ú ◊î◊ï◊ì◊¢◊™ ◊î◊û◊©◊™◊û◊© ◊î◊†◊ï◊õ◊ó◊ô◊™: ${messageId}.
- ◊î◊™◊í◊ï◊ë◊î ◊ú◊û◊©◊™◊û◊© ◊™◊û◊ô◊ì ◊¶◊®◊ô◊õ◊î ◊ú◊î◊ô◊ï◊™ ◊ë◊¢◊ë◊®◊ô◊™.
- ◊ê◊ù ◊ê◊ô◊†◊ö ◊ë◊ò◊ï◊ó, ◊ë◊ß◊© ◊î◊ë◊î◊®◊î ◊ë◊ê◊û◊¶◊¢◊ï◊™ ◊§◊¢◊ï◊ú◊™ "text".

◊™◊í◊ï◊ë◊™ JSON:
`;

        // --- Log the Prompt before sending ---
        console.log("\n===================== Gemini Prompt Start =====================");
        // console.log(geminiPrompt); // Keep this commented unless debugging - it's very long
        console.log(`Prompt length: ${geminiPrompt.length} chars`);
        console.log(`User Message for Prompt (ID ${messageId}): ${msg.text || '[No Text]'}`);
        console.log(`Includes Search Results: ${!!searchResultsText.includes('--- ◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ó◊®◊ï◊†◊ï◊™ ---')}`);
        console.log("====================== Gemini Prompt End ======================\n");

        try {
            const jsonResponse = await callGemini(geminiPrompt);

            // Handle potential multiple actions
            if (jsonResponse.replies && Array.isArray(jsonResponse.replies)) {
                console.log(`‚ö° Received ${jsonResponse.replies.length} actions from Gemini.`);
                for (const actionData of jsonResponse.replies) {
                    if (!actionData || !actionData.replyToTelegramMessageId) {
                        console.warn("‚ö†Ô∏è Skipping action in 'replies' array due to missing data or replyToTelegramMessageId:", actionData);
                        continue;
                    }
                    // *** Pass the current search results context to the handler ***
                    await handleGeminiAction(actionData, msg, recentSearchResults[chatId]);
                    await delay(600);
                }
            } else {
                 if (!jsonResponse || !jsonResponse.replyToTelegramMessageId) {
                     console.warn("‚ö†Ô∏è Gemini response is missing replyToTelegramMessageId. Using fallback.", jsonResponse);
                     jsonResponse.replyToTelegramMessageId = msg.message_id;
                 }
                // *** Pass the current search results context to the handler ***
                await handleGeminiAction(jsonResponse, msg, recentSearchResults[chatId]);
            }

        } catch (geminiError) {
            console.error("‚ùå Error calling Gemini or processing response:", geminiError);
            let errorMsgToSend = `◊°◊ú◊ô◊ó◊î, ◊†◊™◊ß◊ú◊™◊ô ◊ë◊©◊í◊ô◊ê◊î ◊ë◊†◊ô◊°◊ô◊ï◊ü ◊ú◊î◊ë◊ô◊ü ◊ê◊™ ◊î◊ë◊ß◊©◊î ◊©◊ú◊ö.`;
            // Avoid sending overly technical details from Gemini errors to user unless necessary
            if (geminiError.message && (geminiError.message.includes("JSON") || geminiError.message.includes("◊ó◊°◊û◊î"))) {
                 errorMsgToSend += `\n(◊©◊í◊ô◊ê◊î ◊§◊†◊ô◊û◊ô◊™)`;
            } else if (geminiError.message) {
                 errorMsgToSend += `\n◊§◊®◊ò◊ô◊ù: ${geminiError.message}`; // Show other error types
            }
            await sendMessageAndLog(chatId, errorMsgToSend, { reply_to_message_id: msg.message_id });
        }
    });

    // --- Centralized Error Listeners (Same as before) ---
    bot.on('polling_error', (error) => {
        console.error(`üÖøÔ∏è Polling error: ${error.code || 'Unknown Code'} - ${error.message || error}`);
        if (error.code === 'EFATAL') {
            console.error("FATAL POLLING ERROR! Bot may not recover without restart.");
        }
    });
    bot.on('webhook_error', (error) => {
        console.error(`üï∏Ô∏è Webhook error: ${error.code || 'Unknown Code'} - ${error.message || error}`);
    });
    bot.on('error', (error) => { // General catch-all for library errors
        console.error('ü§ñ General Telegram Bot Error:', error);
    });

    console.log("‚úÖ Telegram message and error listeners are active.");
}


// --- Gemini Interaction (Uses specific model, same parsing logic) ---
async function callGemini(promptText) {
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`;

    const requestPayload = {
        contents: [{ parts: [{ text: promptText }] }],
        generationConfig: {
             temperature: 0.6, // Slightly lower temp for more consistent JSON?
        },
        safetySettings: [
             { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
             { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
             { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
             { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
        ]
    };

    console.log(`üß† Calling Gemini model: ${GEMINI_MODEL_NAME}...`);

    let response;
    let retryCount = 0;
    const maxRetries = 2; // Reduce retries slightly
    const retryDelayMs = 2000;

    while (retryCount < maxRetries) {
        try {
            response = await axios.post(GEMINI_API_URL, requestPayload, {
                headers: { 'Content-Type': 'application/json' },
                timeout: 45000 // Add timeout for Gemini API call
            });

             if (!response.data || !response.data.candidates || !Array.isArray(response.data.candidates) || response.data.candidates.length === 0 ||
                 !response.data.candidates[0].content || !response.data.candidates[0].content.parts || !Array.isArray(response.data.candidates[0].content.parts) || response.data.candidates[0].content.parts.length === 0 ||
                 !response.data.candidates[0].content.parts[0].text) {

                 if (response.data.promptFeedback?.blockReason) {
                     const blockReason = response.data.promptFeedback.blockReason;
                     console.error(`‚ùå Gemini response blocked due to: ${blockReason}.`);
                     const safetyRatings = response.data.promptFeedback.safetyRatings || [];
                     console.error("Safety Ratings:", JSON.stringify(safetyRatings));
                      // Log more context if blocked
                      console.error("Prompt leading to block (first 500 chars):", promptText.substring(0, 500) + "...");
                      throw new Error(`◊î◊ë◊ß◊©◊î ◊†◊ó◊°◊û◊î ◊¢◊ú ◊ô◊ì◊ô ◊û◊°◊†◊†◊ô ◊î◊™◊ï◊õ◊ü ◊©◊ú Gemini (◊°◊ô◊ë◊î: ${blockReason}). ◊†◊°◊î ◊ú◊†◊°◊ó ◊û◊ó◊ì◊©.`);
                 }
                 if (response.data.candidates?.[0]?.finishReason && response.data.candidates[0].finishReason !== 'STOP') {
                      console.error(`‚ùå Gemini response finished unexpectedly: ${response.data.candidates[0].finishReason}`);
                      console.error("Full Candidate:", JSON.stringify(response.data.candidates[0]));
                       if(response.data.candidates[0].finishReason === 'MAX_TOKENS') {
                           throw new Error("◊™◊í◊ï◊ë◊™ Gemini ◊†◊ß◊ò◊¢◊î ◊¢◊ß◊ë ◊û◊í◊ë◊ú◊™ ◊ê◊ï◊®◊ö.");
                       }
                       throw new Error(`◊™◊í◊ï◊ë◊î ◊ú◊ê ◊™◊ß◊ô◊†◊î ◊û-Gemini (◊°◊ô◊ë◊î: ${response.data.candidates[0].finishReason}).`);
                  }

                 console.error("‚ùå Gemini response missing expected structure or text content:", JSON.stringify(response.data, null, 2));
                 throw new Error("◊™◊í◊ï◊ë◊î ◊ú◊ê ◊™◊ß◊ô◊†◊î ◊ê◊ï ◊®◊ô◊ß◊î ◊û-Gemini.");
             }

             const responseText = response.data.candidates[0].content.parts[0].text;
            console.log(`‚úÖ Gemini API call successful (attempt ${retryCount + 1}). Raw Text Length: ${responseText.length}`);

             const jsonResponse = attemptJsonParsingRecovery(responseText);
             if(jsonResponse){
                 console.log("ü§ñ Gemini Response (Parsed/Recovered JSON):", JSON.stringify(jsonResponse, null, 2));
                  if (typeof jsonResponse !== 'object' || jsonResponse === null) {
                       console.error("‚ùå Recovered response is not a valid object:", jsonResponse);
                       throw new Error("◊™◊í◊ï◊ë◊™ Gemini ◊§◊ï◊¢◊†◊ó◊î ◊ê◊ö ◊ê◊ô◊†◊î ◊ê◊ï◊ë◊ô◊ô◊ß◊ò JSON ◊™◊ß◊†◊ô.");
                  }
                 return jsonResponse;
             } else {
                 console.error("‚ùå Failed to parse Gemini response as JSON even after recovery.");
                 console.error("--- Raw Gemini Response Text Start ---");
                 console.error(responseText);
                 console.error("--- Raw Gemini Response Text End ---");
                  throw new Error("◊™◊í◊ï◊ë◊™ Gemini ◊ê◊ô◊†◊î ◊ë◊§◊ï◊®◊û◊ò JSON ◊™◊ß◊†◊ô. ◊ë◊ì◊ï◊ß ◊ê◊ù ◊ô◊© ◊™◊ï◊õ◊ü ◊ú◊ê ◊¶◊§◊ï◊ô ◊ë◊™◊í◊ï◊ë◊î.");
             }

        } catch (apiError) {
            // Handle specific thrown errors first
             if (apiError instanceof Error && (apiError.message.includes("◊ó◊°◊û◊î") || apiError.message.includes("JSON ◊™◊ß◊†◊ô") || apiError.message.includes("◊™◊í◊ï◊ë◊î ◊ú◊ê ◊™◊ß◊ô◊†◊î"))) {
                  throw apiError; // Re-throw specific parsing/safety/format errors immediately
             }

            retryCount++;
             // Handle Axios / network / timeout errors
             let errorMessage = apiError.message;
             if (apiError.code === 'ECONNABORTED') {
                 errorMessage = `Timeout waiting for Gemini API response (${apiError.config.timeout}ms).`;
             } else if (apiError.response) {
                 errorMessage = `Gemini API error: ${apiError.response.status} ${apiError.response.statusText} - ${apiError.response.data?.error?.message || ''}`;
             }
            console.error(`‚ùå Gemini API error (attempt ${retryCount}/${maxRetries}): ${errorMessage}`);

            const statusCode = apiError.response?.status;
             if ((statusCode === 429 || statusCode === 500 || statusCode === 503 || apiError.code === 'ECONNABORTED' || apiError.message.includes('timeout')) && retryCount < maxRetries) { // Retriable server/network errors
                const calculatedDelay = retryDelayMs * Math.pow(2, retryCount - 1);
                console.log(`‚è≥ Retrying Gemini in ${calculatedDelay / 1000} seconds... (Status: ${statusCode || apiError.code || 'N/A'})`);
                await delay(calculatedDelay);
             } else {
                 console.error(`‚ùå Unrecoverable API error or max retries reached. Not retrying.`);
                 // Throw a user-friendly error for common issues
                  if (statusCode === 400) {
                      throw new Error(`◊©◊í◊ô◊ê◊™ Gemini (400 - Bad Request): ◊ë◊ì◊ï◊ß ◊ê◊™ ◊û◊§◊™◊ó ◊î-API ◊ê◊ï ◊©◊û◊ë◊†◊î ◊î◊ë◊ß◊©◊î ◊™◊ß◊ô◊ü.`);
                  } else if (statusCode === 403) {
                      throw new Error(`◊©◊í◊ô◊ê◊™ Gemini (403 - Forbidden): ◊ë◊ì◊ï◊ß ◊î◊®◊©◊ê◊ï◊™ API Key ◊ê◊ï ◊î◊í◊ì◊®◊ï◊™ ◊§◊®◊ï◊ô◊ß◊ò Google Cloud.`);
                  }
                  throw new Error(`◊™◊ß◊©◊ï◊®◊™ ◊¢◊ù Gemini ◊†◊õ◊©◊ú◊î: ${errorMessage}`); // Throw generic error for others
             }
        }
    }
     // Only reached if all retries failed for retriable errors
     throw new Error(`Gemini API ◊†◊õ◊©◊ú ◊ú◊ê◊ó◊® ${maxRetries} ◊†◊ô◊°◊ô◊ï◊†◊ï◊™.`);
}

// --- Robust JSON Parsing (Same as before) ---
function attemptJsonParsingRecovery(responseText) {
    if (typeof responseText !== 'string') return null;
    let text = responseText.trim();
    if (text.length === 0) return null;

     if (text.startsWith("```json") && text.endsWith("```")) {
         text = text.substring(7, text.length - 3).trim();
     } else if (text.startsWith("```") && text.endsWith("```")) {
          text = text.substring(3, text.length - 3).trim();
     }

    try {
        const parsed = JSON.parse(text);
        if (typeof parsed === 'object' && parsed !== null) return parsed;
    } catch (e) {}

    let match = text.match(/^\{[\s\S]*\}$/m) || text.match(/^\[[\s\S]*\]$/m);
    if (match) {
        try {
            const parsed = JSON.parse(match[0]);
             if (typeof parsed === 'object' && parsed !== null) {
                 if (Array.isArray(parsed)) {
                      return { replies: parsed }; // Standardize array response
                 }
                 return parsed;
             }
        } catch (e) {}
    }

    console.error("‚ùå Recovery: Failed all attempts to parse or recover JSON structure from text.");
    return null;
}

// --- Action Handlers (Main router - UPDATED) ---
async function handleGeminiAction(actionData, originalMsg, currentSearchResults) {
    const chatId = originalMsg.chat.id;
    const replyToId = actionData.replyToTelegramMessageId;

     if(!replyToId){
         console.error("‚ùå CRITICAL: Gemini action response is missing 'replyToTelegramMessageId'. Cannot proceed reliably.", actionData);
         await sendMessageAndLog(chatId, "‚ö†Ô∏è ◊©◊í◊ô◊ê◊î ◊§◊†◊ô◊û◊ô◊™: ◊ó◊°◊® ◊û◊ñ◊î◊î ◊î◊ï◊ì◊¢◊î ◊ú◊û◊¢◊†◊î ◊û◊î◊ë◊ô◊†◊î ◊î◊û◊ú◊ê◊õ◊ï◊™◊ô◊™.", { reply_to_message_id: originalMsg.message_id });
         return;
     }

    console.log(`üé¨ Executing action: ${actionData.action || 'N/A'} (Replying to Msg ID: ${replyToId})`);

    // --- Send Intermediate Message if provided ---
     if (actionData.message && actionData.action !== 'text') { // Don't send intermediate for simple text replies
         try {
             await sendMessageAndLog(chatId, actionData.message, { reply_to_message_id: replyToId });
             await delay(300); // Short delay after intermediate message
         } catch (sendError) {
              console.warn("‚ö†Ô∏è Failed to send intermediate message:", sendError.message);
         }
     }
     // --- ---

    try {
        switch (actionData.action) {
            case 'text':
                if (actionData.message) { // Message is mandatory here
                    await sendMessageAndLog(chatId, actionData.message, { reply_to_message_id: replyToId });
                } else {
                     console.warn("‚ö†Ô∏è Action 'text' received without 'message' content.");
                     await sendMessageAndLog(chatId, "‚ùì ◊ß◊ô◊ë◊ú◊™◊ô ◊î◊ï◊®◊ê◊î ◊ú◊©◊ú◊ï◊ó ◊î◊ï◊ì◊¢◊î ◊®◊ô◊ß◊î.", { reply_to_message_id: replyToId });
                 }
                break;

            case 'send_email':
                await handleSendEmailAction(actionData, originalMsg); // Handles its own confirmation
                break;

            case 'reply_email':
                await handleReplyEmailAction(actionData, originalMsg); // Handles its own confirmation
                break;

            case 'add_memory':
                const added = handleAddMemoryAction(actionData);
                // Confirmation logic (prefer Gemini's message if available)
                 if (!actionData.message) { // If Gemini didn't provide a specific message
                     await sendMessageAndLog(chatId, added ? "üß† ◊§◊®◊ò ◊î◊û◊ô◊ì◊¢ ◊†◊©◊û◊® ◊ë◊ñ◊ô◊õ◊®◊ï◊ü." : "‚ö†Ô∏è ◊ú◊ê ◊î◊¶◊ú◊ó◊™◊ô ◊ú◊©◊û◊ï◊® ◊ê◊™ ◊î◊û◊ô◊ì◊¢.", { reply_to_message_id: replyToId });
                 } // If Gemini provided a message, it was already sent as intermediate
                break;

            case 'delete_memory':
                 const deleted = handleDeleteMemoryAction(actionData);
                 if (!actionData.message) {
                     await sendMessageAndLog(chatId, deleted ? "üß† ◊î◊ñ◊ô◊õ◊®◊ï◊ü ◊†◊û◊ó◊ß." : "‚ùì ◊ú◊ê ◊†◊û◊¶◊ê ◊ñ◊ô◊õ◊®◊ï◊ü ◊¢◊ù ◊î◊û◊ñ◊î◊î ◊©◊¶◊ï◊ô◊ô◊ü ◊ú◊û◊ó◊ô◊ß◊î.", { reply_to_message_id: replyToId });
                 }
                break;

            // *** NEW ACTIONS ***
             case 'search_email':
                 await handleSearchEmailAction(actionData, originalMsg); // Handles its own flow (direct send or results back to AI)
                 break;
             case 'forward_email_from_search':
                 // Pass search results context for validation if needed
                 await handleForwardEmailFromSearchAction(actionData, originalMsg, currentSearchResults); // Handles its own confirmation
                 break;
             case 'forward_attachment_from_search':
                  // Pass search results context for validation if needed
                 await handleForwardAttachmentFromSearchAction(actionData, originalMsg, currentSearchResults); // Handles its own confirmation
                 break;
            // *** END NEW ACTIONS ***

            default:
                console.warn(`‚ùì Unhandled action type from Gemini: ${actionData.action}`);
                await sendMessageAndLog(chatId, `ü§î ◊ß◊ô◊ë◊ú◊™◊ô ◊§◊¢◊ï◊ú◊î ◊ú◊ê ◊û◊ï◊õ◊®◊™: '${actionData.action}'. ◊ê◊†◊ô ◊¢◊ì◊ô◊ô◊ü ◊ú◊ï◊û◊ì/◊™.`, { reply_to_message_id: replyToId });
        }
    } catch (error) {
        console.error(`‚ùå Error executing action '${actionData.action}':`, error);
        // Avoid double reporting if intermediate message failed
        if (!(actionData.message && actionData.action !== 'text')) {
            await sendMessageAndLog(chatId, `‚ö†Ô∏è ◊°◊ú◊ô◊ó◊î, ◊ß◊®◊™◊î ◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊†◊ô◊°◊ô◊ï◊ü ◊ë◊ô◊¶◊ï◊¢ ◊î◊§◊¢◊ï◊ú◊î (${actionData.action}).\n ◊§◊®◊ò◊ô◊ù: \`${error.message}\``, { reply_to_message_id: replyToId, parse_mode: 'Markdown'});
        }
    }
}

// --- Specific Action Handlers ---

// (makeBody and makeMultipartBody remain the same)
function makeBody(to, from, subject, message, headers = {}) {
    const emailLines = [
        `To: ${to}`,
        `From: ${from}`,
        'Content-Type: text/plain; charset=utf-8',
        'MIME-Version: 1.0',
        `Subject: =?UTF-8?B?${Buffer.from(subject).toString('base64')}?=`,
    ];
    if (headers['In-Reply-To']) emailLines.push(`In-Reply-To: ${headers['In-Reply-To']}`);
    if (headers['References']) emailLines.push(`References: ${headers['References']}`);
    emailLines.push('', message);
    const email = emailLines.join('\n');
    return Buffer.from(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function makeMultipartBody(to, from, subject, message, attachmentPath, attachmentOriginalName, originalHeaders = {}) {
    const boundary = `boundary_${Date.now().toString(16)}`;
    const attachment = fs.readFileSync(attachmentPath);
    const encodedAttachment = attachment.toString('base64');
    const filename = path.basename(attachmentOriginalName || attachmentPath); // Use original name if provided
    const mimeType = mime.lookup(filename) || 'application/octet-stream';
    const emailLines = [
        `From: ${from}`,
        `To: ${to}`,
        `Subject: =?UTF-8?B?${Buffer.from(subject).toString('base64')}?=`,
        `MIME-Version: 1.0`,
        `Content-Type: multipart/mixed; boundary="${boundary}"`,
    ];
    if (originalHeaders['In-Reply-To']) emailLines.push(`In-Reply-To: ${originalHeaders['In-Reply-To']}`);
    if (originalHeaders['References']) emailLines.push(`References: ${originalHeaders['References']}`);
    emailLines.push(
        '',
        `--${boundary}`,
        `Content-Type: text/plain; charset="UTF-8"`,
        `Content-Transfer-Encoding: base64`,
        '', Buffer.from(message).toString('base64'),
        '',
        `--${boundary}`,
        // Ensure filename* is UTF-8 encoded for non-ASCII names
        `Content-Type: ${mimeType}; name*=UTF-8''${encodeURIComponent(filename)}`,
        `Content-Disposition: attachment; filename*=UTF-8''${encodeURIComponent(filename)}`,
        `Content-Transfer-Encoding: base64`,
        '', encodedAttachment,
        '',
        `--${boundary}--`
    );
    const email = emailLines.join('\r\n'); // Use CRLF for email line endings
    return Buffer.from(email).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}


async function handleSendEmailAction(actionData, originalMsg) {
    console.log(`üì® Handling send_email: To=${actionData.to}, Subject=${actionData.subject}`);
     if (!actionData.to || !actionData.subject || !actionData.body) {
         throw new Error("◊ô◊© ◊ú◊û◊ú◊ê ◊†◊û◊¢◊ü ('to'), ◊†◊ï◊©◊ê ('subject'), ◊ï◊í◊ï◊£ ◊î◊ï◊ì◊¢◊î ('body') ◊ú◊©◊ú◊ô◊ó◊™ ◊ê◊ô◊û◊ô◊ô◊ú.");
     }
    const replyToTelegramId = actionData.replyToTelegramMessageId || originalMsg.message_id;

    let attachmentPath = null;
    let attachmentOriginalName = null;
    if (actionData.attachmentTelegramMessageId) {
         const fileData = telegramFileMap.get(Number(actionData.attachmentTelegramMessageId));
        if (fileData && fs.existsSync(fileData.filePath)) {
            attachmentPath = fileData.filePath;
            attachmentOriginalName = fileData.originalName; // Get original name
            console.log(`üìé Attaching file: ${attachmentPath} (Original: ${attachmentOriginalName})`);
        } else {
            console.warn(`‚ö†Ô∏è Attachment file for Telegram message ID ${actionData.attachmentTelegramMessageId} not found or invalid.`);
             await sendMessageAndLog(originalMsg.chat.id, "‚ö†Ô∏è ◊ú◊ê ◊û◊¶◊ê◊™◊ô ◊ê◊™ ◊î◊ß◊ï◊ë◊• ◊©◊ë◊ô◊ß◊©◊™ ◊ú◊¶◊®◊£. ◊î◊û◊ô◊ô◊ú ◊ô◊©◊ú◊ó ◊ë◊ú◊¢◊ì◊ô◊ï.", { reply_to_message_id: replyToTelegramId });
        }
    }

    try {
        const profile = await gmail.users.getProfile({ userId: 'me' });
        const userEmail = profile.data.emailAddress;
        if (!userEmail) throw new Error("◊ú◊ê ◊†◊ô◊™◊ü ◊î◊ô◊î ◊ú◊ß◊ë◊ú ◊ê◊™ ◊õ◊™◊ï◊ë◊™ ◊î◊û◊ô◊ô◊ú ◊©◊ú ◊î◊û◊©◊™◊û◊©.");

        let rawEmail;
        if (attachmentPath) {
            rawEmail = makeMultipartBody(actionData.to, userEmail, actionData.subject, actionData.body, attachmentPath, attachmentOriginalName);
        } else {
            rawEmail = makeBody(actionData.to, userEmail, actionData.subject, actionData.body);
        }

        const sentMessage = await gmail.users.messages.send({ userId: 'me', requestBody: { raw: rawEmail } });
        console.log(`‚úÖ Gmail API: Email sent successfully to ${actionData.to} (ID: ${sentMessage.data.id})`);

        // Send SUCCESS confirmation
        await sendMessageAndLog(originalMsg.chat.id, `‚úÖ ◊î◊û◊ô◊ô◊ú ◊†◊©◊ú◊ó ◊ë◊î◊¶◊ú◊ó◊î ◊ê◊ú: ${actionData.to}`, { reply_to_message_id: replyToTelegramId });

        // Clean up temp file AFTER successful send
        if (attachmentPath && actionData.attachmentTelegramMessageId) {
            cleanupTemporaryFile(attachmentPath, Number(actionData.attachmentTelegramMessageId));
        }
    } catch (error) {
        console.error("‚ùå Failed to send email via Gmail API:", error.response?.data?.error?.message || error.message);
        throw new Error(`◊©◊í◊ô◊ê◊î ◊ë◊©◊ú◊ô◊ó◊™ ◊î◊û◊ô◊ô◊ú: ${error.response?.data?.error?.message || error.message}`);
    }
}

async function handleReplyEmailAction(actionData, originalMsg) {
    console.log(`‚Ü™Ô∏è Handling reply_email: GmailID=${actionData.gmailMessageId}, Subject=${actionData.subject}`);
    if (!actionData.gmailMessageId || !actionData.subject || !actionData.body) {
         throw new Error("◊ô◊© ◊ú◊¶◊ô◊ô◊ü ◊û◊ñ◊î◊î ◊ì◊ï◊ê\"◊ú ◊û◊ß◊ï◊®◊ô ('gmailMessageId'), ◊†◊ï◊©◊ê ('subject'), ◊ï◊í◊ï◊£ ◊™◊©◊ï◊ë◊î ('body') ◊ú◊û◊¢◊†◊î.");
     }
    const replyToTelegramId = actionData.replyToTelegramMessageId || originalMsg.message_id;

    let attachmentPath = null;
    let attachmentOriginalName = null;
     if (actionData.attachmentTelegramMessageId) {
        const fileData = telegramFileMap.get(Number(actionData.attachmentTelegramMessageId));
         if (fileData && fs.existsSync(fileData.filePath)) {
             attachmentPath = fileData.filePath;
             attachmentOriginalName = fileData.originalName;
             console.log(`üìé Attaching file to reply: ${attachmentPath} (Original: ${attachmentOriginalName})`);
         } else {
             console.warn(`‚ö†Ô∏è Attachment file for Telegram message ID ${actionData.attachmentTelegramMessageId} not found for reply.`);
              await sendMessageAndLog(originalMsg.chat.id, "‚ö†Ô∏è ◊ú◊ê ◊û◊¶◊ê◊™◊ô ◊ê◊™ ◊î◊ß◊ï◊ë◊• ◊©◊ë◊ô◊ß◊©◊™ ◊ú◊¶◊®◊£ ◊ú◊™◊©◊ï◊ë◊î. ◊î◊û◊¢◊†◊î ◊ú◊û◊ô◊ô◊ú ◊ô◊©◊ú◊ó ◊ë◊ú◊¢◊ì◊ô◊ï.", { reply_to_message_id: replyToTelegramId });
         }
     }

     try {
        const originalMsgData = await gmail.users.messages.get({
             userId: 'me',
             id: actionData.gmailMessageId,
             format: 'metadata', // Need metadata for headers and threadId
             metadataHeaders: ['Subject', 'From', 'To', 'Message-ID', 'References', 'In-Reply-To']
         });

        const payload = originalMsgData.data.payload;
         if(!payload || !payload.headers){ throw new Error("◊ú◊ê ◊†◊ô◊™◊ü ◊î◊ô◊î ◊ú◊ß◊ë◊ú ◊ê◊™ ◊î◊õ◊ï◊™◊®◊ï◊™ ◊û◊î◊ê◊ô◊û◊ô◊ô◊ú ◊î◊û◊ß◊ï◊®◊ô.");}
        const headers = payload.headers;

        const originalMessageId = headers.find(h => h.name.toLowerCase() === 'message-id')?.value;
        const originalReferences = headers.find(h => h.name.toLowerCase() === 'references')?.value;
        const originalInReplyTo = headers.find(h => h.name.toLowerCase() === 'in-reply-to')?.value || originalMessageId; // Fallback to Message-ID
         const originalFromHeader = headers.find(h => h.name.toLowerCase() === 'from')?.value || '';
         const originalToHeader = headers.find(h => h.name.toLowerCase() === 'to')?.value || ''; // Needed to determine sender address in reply

        // Find the actual sender's address from the original 'To' header if replying to own sent mail, otherwise use 'From'.
        // This isn't perfect but handles common reply scenarios.
        const profile = await gmail.users.getProfile({ userId: 'me' });
        const userEmail = profile.data.emailAddress;
        if (!userEmail) throw new Error("◊ú◊ê ◊†◊ô◊™◊ü ◊î◊ô◊î ◊ú◊ß◊ë◊ú ◊ê◊™ ◊õ◊™◊ï◊ë◊™ ◊î◊û◊ô◊ô◊ú ◊©◊ú ◊î◊û◊©◊™◊û◊©.");

        let replyToAddress;
        const fromAddress = originalFromHeader.match(/<([^>]+)>/)?.[1] || originalFromHeader.trim();

        // Simple check: if the original sender is the user, reply to the 'To' address. Otherwise, reply to 'From'.
        // This might need refinement for complex CC/BCC scenarios.
        if (fromAddress.toLowerCase() === userEmail.toLowerCase()) {
            replyToAddress = originalToHeader.match(/<([^>]+)>/)?.[1] || originalToHeader.trim();
        } else {
            replyToAddress = fromAddress;
        }

         if(!replyToAddress) {
             console.error("Original From:", originalFromHeader);
             console.error("Original To:", originalToHeader);
             console.error("User Email:", userEmail);
             throw new Error("◊ú◊ê ◊†◊ô◊™◊ü ◊î◊ô◊î ◊ú◊ß◊ë◊ï◊¢ ◊ê◊™ ◊†◊û◊¢◊ü ◊î◊™◊©◊ï◊ë◊î ◊û◊î◊õ◊ï◊™◊®◊ï◊™ 'From' ◊ê◊ï 'To'.");
         }


         // Construct threading headers
         let references = originalReferences ? `${originalReferences} ${originalMessageId}` : originalMessageId;
         if (!originalMessageId) { references = originalReferences || ''; } // Avoid 'undefined'

        const replyHeaders = {};
         if(originalInReplyTo) replyHeaders['In-Reply-To'] = originalInReplyTo;
         if(references) replyHeaders['References'] = references;

        // Prepare raw email
        let rawEmail;
         if (attachmentPath) {
             rawEmail = makeMultipartBody(replyToAddress, userEmail, actionData.subject, actionData.body, attachmentPath, attachmentOriginalName, replyHeaders);
         } else {
             rawEmail = makeBody(replyToAddress, userEmail, actionData.subject, actionData.body, replyHeaders);
         }

        const sentReply = await gmail.users.messages.send({
             userId: 'me',
             requestBody: {
                 raw: rawEmail,
                 threadId: originalMsgData.data.threadId // Ensure threading
             },
         });
         console.log(`‚úÖ Gmail API: Email reply sent successfully for Gmail ID ${actionData.gmailMessageId} (Thread: ${originalMsgData.data.threadId}, Reply ID: ${sentReply.data.id})`);

          // Send SUCCESS confirmation
         await sendMessageAndLog(originalMsg.chat.id, `‚úÖ ◊î◊û◊¢◊†◊î ◊ú◊û◊ô◊ô◊ú (ID: ${actionData.gmailMessageId}) ◊†◊©◊ú◊ó ◊ë◊î◊¶◊ú◊ó◊î ◊ê◊ú: ${replyToAddress}`, { reply_to_message_id: replyToTelegramId });

        // Clean up temp file AFTER successful send
         if (attachmentPath && actionData.attachmentTelegramMessageId) {
             cleanupTemporaryFile(attachmentPath, Number(actionData.attachmentTelegramMessageId));
         }

     } catch (error) {
         console.error(`‚ùå Failed to reply to email (Gmail ID: ${actionData.gmailMessageId}):`, error.response?.data?.error?.message || error.message);
         throw new Error(`◊©◊í◊ô◊ê◊î ◊ë◊©◊ú◊ô◊ó◊™ ◊î◊û◊¢◊†◊î ◊ú◊û◊ô◊ô◊ú: ${error.response?.data?.error?.message || error.message}`);
     }
}

function handleAddMemoryAction(actionData) {
    if (!actionData.memoryData || !actionData.memoryData.info) {
         console.warn("‚ö†Ô∏è Attempted to add memory without 'memoryData.info' field.");
         return false;
    }
    try {
        const memoryId = Date.now(); // Simple unique ID
        const newMemory = {
            id: memoryId,
            timestamp: memoryId,
            info: actionData.memoryData.info,
            person: actionData.memoryData.person || null,
            type: actionData.memoryData.type || null
        };
        // Load current memories safely
        let currentMemories = [];
        try {
            if (fs.existsSync(MEMORIES_PATH)) {
                 const data = fs.readFileSync(MEMORIES_PATH, 'utf8');
                 const parsed = JSON.parse(data);
                 if(Array.isArray(parsed)) currentMemories = parsed;
             }
         } catch (loadErr) { console.error("Error loading memories before adding:", loadErr); }

        currentMemories.unshift(newMemory); // Add to beginning (most recent)
         memories = currentMemories; // Update global
        saveMemories(); // Persist
        console.log(`üß† Memory added (ID: ${memoryId}): "${newMemory.info.substring(0, 50)}..."`);
         return true;
    } catch (err) {
         console.error("‚ùå CRITICAL: Failed to save memory:", err);
         return false;
    }
}

function handleDeleteMemoryAction(actionData) {
     if (actionData.memoryIdToDelete === undefined || actionData.memoryIdToDelete === null) {
         console.warn("‚ö†Ô∏è Attempted to delete memory without specifying 'memoryIdToDelete'.");
         return false;
     }
     try {
        const idToDelete = Number(actionData.memoryIdToDelete);
         if(isNaN(idToDelete)){
             console.warn(`‚ö†Ô∏è Invalid memory ID provided for deletion: '${actionData.memoryIdToDelete}'`);
             return false;
         }

        // Load fresh memories safely before filtering
         let currentMemories = [];
         try {
             if (fs.existsSync(MEMORIES_PATH)) {
                 const data = fs.readFileSync(MEMORIES_PATH, 'utf8');
                 const parsed = JSON.parse(data);
                  if(Array.isArray(parsed)) currentMemories = parsed;
              }
          } catch (loadErr) { console.error("Error loading memories before deleting:", loadErr); }

        const initialLength = currentMemories.length;
        const filteredMemories = currentMemories.filter(mem => mem.id !== idToDelete);

        if (filteredMemories.length < initialLength) {
             memories = filteredMemories; // Update global
            saveMemories(); // Persist
            console.log(`üß† Memory deleted (ID: ${idToDelete})`);
            return true;
        } else {
             console.log(`‚ùì Memory ID ${idToDelete} not found for deletion.`);
             return false;
         }
    } catch (err) {
        console.error("‚ùå CRITICAL: Failed to delete memory:", err);
        return false;
    }
}


// --- *** NEW: Gmail Search Action Handler *** ---
async function handleSearchEmailAction(actionData, originalMsg) {
    const chatId = originalMsg.chat.id;
    const replyToTelegramId = actionData.replyToTelegramMessageId || originalMsg.message_id;
    const query = actionData.query || '';
    const searchPeriod = actionData.searchPeriod || null;

    if (!query && !searchPeriod) {
        throw new Error("◊ô◊© ◊ú◊°◊§◊ß ◊û◊ô◊ú◊ï◊™ ◊ó◊ô◊§◊ï◊© ('query') ◊ê◊ï ◊™◊ß◊ï◊§◊™ ◊ñ◊û◊ü ('searchPeriod') ◊ú◊ó◊ô◊§◊ï◊© ◊ê◊ô◊û◊ô◊ô◊ú◊ô◊ù.");
    }

    console.log(`üîç Handling search_email: Query='${query}', Period='${searchPeriod}'`);

    try {
        // Build the Gmail search query string
        const gmailQuery = buildGmailQuery(query, searchPeriod);
        if (!gmailQuery) {
            throw new Error("◊ú◊ê ◊†◊ô◊™◊ü ◊î◊ô◊î ◊ú◊ô◊¶◊ï◊® ◊©◊ê◊ô◊ú◊™◊™ ◊ó◊ô◊§◊ï◊© ◊ó◊ï◊ß◊ô◊™ ◊û◊î◊§◊®◊û◊ò◊®◊ô◊ù ◊©◊°◊ï◊§◊ß◊ï.");
        }
        console.log(`üìä Constructed Gmail Query: ${gmailQuery}`);

        // Perform the search
        const listResponse = await gmail.users.messages.list({
            userId: 'me',
            q: gmailQuery,
            maxResults: MAX_SEARCH_RESULTS
        });

        const messages = listResponse.data.messages || [];
        const resultSizeEstimate = listResponse.data.resultSizeEstimate || 0;
        console.log(`üîç Found ${messages.length} messages (Estimate: ${resultSizeEstimate}) matching query.`);

        if (messages.length === 0) {
            await sendMessageAndLog(chatId, "ü§∑ ◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊î◊ï◊ì◊¢◊ï◊™ ◊ì◊ï◊ê\"◊ú ◊î◊™◊ï◊ê◊û◊ï◊™ ◊ú◊ó◊ô◊§◊ï◊© ◊©◊ú◊ö.", { reply_to_message_id: replyToTelegramId });
            recentSearchResults[chatId] = null; // Clear previous results
            return;
        }

        // Fetch details for each message
        const detailedResults = [];
        // Limit details fetching to avoid hitting rate limits aggressively
        const messagesToFetch = messages.slice(0, MAX_SEARCH_RESULTS);

        for (const messageHeader of messagesToFetch) {
            try {
                const msg = await gmail.users.messages.get({
                    userId: 'me',
                    id: messageHeader.id,
                    format: 'full' // Need full to get snippet, date, attachments easily
                });

                const payload = msg.data.payload;
                if (!payload) continue;
                const headers = payload.headers || [];

                const subject = headers.find(h => h.name.toLowerCase() === 'subject')?.value || 'No Subject';
                const from = headers.find(h => h.name.toLowerCase() === 'from')?.value || 'Unknown Sender';
                const dateHeader = headers.find(h => h.name.toLowerCase() === 'date')?.value;
                const date = dateHeader ? moment(dateHeader).tz(ISRAEL_TIMEZONE).format('DD/MM/YYYY HH:mm') : 'Unknown Date';
                const snippet = msg.data.snippet || '(◊ê◊ô◊ü ◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î)';

                const attachments = findAttachments(payload); // Use helper

                detailedResults.push({
                    id: msg.data.id,
                    threadId: msg.data.threadId,
                    subject,
                    from,
                    date,
                    snippet: snippet.substring(0, 150), // Keep snippet reasonably short
                    attachments: attachments.map(att => ({ // Include necessary info for forwarding
                        filename: att.filename,
                        mimeType: att.mimeType,
                        size: att.size,
                        partId: att.partId,
                        attachmentId: att.attachmentId
                    }))
                });
                await delay(150); // Small delay between message gets
            } catch (getErr) {
                console.error(`‚ùå Error fetching details for message ID ${messageHeader.id}:`, getErr.message);
                // Add a placeholder or skip? Let's skip for now.
            }
        }
        console.log(`‚ÑπÔ∏è Fetched details for ${detailedResults.length} messages.`);

        // Store results for potential follow-up by AI
        recentSearchResults[chatId] = {
            query: actionData.query, // Store original query/period for context
            searchPeriod: actionData.searchPeriod,
            results: detailedResults
        };

        // --- Decide how to present results ---
        // If search was *only* by date range (no keywords), send directly to user.
        const isDateOnlySearch = !query && searchPeriod;

        if (isDateOnlySearch) {
            console.log("üìÖ Date-only search detected. Sending results directly to user.");
            let resultsMessage = `üì¨ *◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊¢◊ë◊ï◊® ${searchPeriod}:*\n\n`;
            if (detailedResults.length === 0) {
                resultsMessage = `ü§∑ ◊ú◊ê ◊†◊û◊¶◊ê◊ï ◊î◊ï◊ì◊¢◊ï◊™ ◊ì◊ï◊ê"◊ú ◊¢◊ë◊ï◊® ${searchPeriod}.`;
            } else {
                 detailedResults.forEach((res, index) => {
                     resultsMessage += `*${index + 1}.* \`${res.id}\`\n`; // Show ID
                     resultsMessage += `  *◊†◊ï◊©◊ê:* ${res.subject}\n`;
                     resultsMessage += `  *◊û◊ê◊™:* ${res.from}\n`;
                     resultsMessage += `  *◊™◊ê◊®◊ô◊ö:* ${res.date}\n`;
                     resultsMessage += `  *◊™◊¶◊ï◊í◊î ◊û◊ß◊ì◊ô◊û◊î:* ${res.snippet}...\n`;
                     if (res.attachments.length > 0) {
                         resultsMessage += `  üìé ${res.attachments.length} ◊ß◊ë◊¶◊ô◊ù ◊û◊¶◊ï◊®◊§◊ô◊ù\n`;
                     }
                     resultsMessage += `----\n`;
                 });
                 if (messages.length > MAX_SEARCH_RESULTS) {
                     resultsMessage += `\n_(◊î◊ï◊¶◊í◊ï ${MAX_SEARCH_RESULTS} ◊™◊ï◊¶◊ê◊ï◊™ ◊û◊™◊ï◊ö ${messages.length})_`;
                 }
            }
            // Split message if too long
             const messageChunks = splitMessage(resultsMessage, 4000); // Split into chunks
             for (const chunk of messageChunks) {
                 await sendMessageAndLog(chatId, chunk, { parse_mode: 'Markdown', reply_to_message_id: replyToTelegramId });
                 await delay(300); // Delay between chunks
             }

        } else {
            // Keyword search: Send results back to AI for processing
            console.log("üìù Keyword search detected. Sending results back to Gemini.");

            // Format results concisely for the AI prompt
            const resultsForPrompt = formatSearchResultsForPrompt(chatId); // Use the helper

            // Add a system message to history indicating search was done
            addToHistory(chatId, {
                 message_id: Date.now(), // Fake ID
                 from: { id: botInfo.id, first_name: 'System', is_bot: true },
                 chat: { id: chatId },
                 date: Math.floor(Date.now() / 1000),
                 text: `[◊ë◊ï◊¶◊¢ ◊ó◊ô◊§◊ï◊© Gmail ◊¢◊ë◊ï◊®: "${query || ''}" ${searchPeriod || ''}. ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊°◊ï◊§◊ß◊ï ◊ú◊î◊ß◊©◊® ◊©◊ú Gemini.]`
             });


            // Call Gemini again with the results in context
            const followUpPrompt = `
◊î◊û◊©◊™◊û◊© ◊ë◊ô◊ß◊© ◊û◊û◊ö ◊ú◊ó◊§◊© ◊î◊ï◊ì◊¢◊ï◊™ ◊ì◊ï◊ê"◊ú ◊¢◊ù ◊î◊§◊®◊û◊ò◊®◊ô◊ù:
◊©◊ê◊ô◊ú◊™◊î: ${query || '◊ú◊ê ◊¶◊ï◊ô◊†◊î'}
◊™◊ß◊ï◊§◊™ ◊ñ◊û◊ü: ${searchPeriod || '◊ú◊ê ◊¶◊ï◊ô◊†◊î'}

◊ú◊î◊ú◊ü ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊©◊†◊û◊¶◊ê◊ï (${detailedResults.length} ◊î◊ï◊ì◊¢◊ï◊™):
${resultsForPrompt}

---
◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊î◊©◊ô◊ó◊î (${HISTORY_LENGTH} ◊î◊ï◊ì◊¢◊ï◊™ ◊ê◊ó◊®◊ï◊†◊ï◊™):
${getChatHistory(chatId)}
---
◊î◊ï◊ì◊¢◊™ ◊î◊û◊©◊™◊û◊© ◊î◊û◊ß◊ï◊®◊ô◊™ (◊©◊í◊®◊û◊î ◊ú◊ó◊ô◊§◊ï◊©, ID: ${originalMsg.message_id}):
${originalMsg.text || '[◊ê◊ô◊ü ◊ò◊ß◊°◊ò ◊ë◊î◊ï◊ì◊¢◊î]'}

--- ◊î◊ï◊®◊ê◊ï◊™ ◊ú◊î◊û◊©◊ö ---
◊ë◊î◊™◊ë◊°◊° ◊¢◊ú ◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊ï◊î◊ë◊ß◊©◊î ◊î◊û◊ß◊ï◊®◊ô◊™ ◊©◊ú ◊î◊û◊©◊™◊û◊©, ◊û◊î ◊î◊¶◊¢◊ì ◊î◊ë◊ê?
- ◊î◊ê◊ù ◊ú◊°◊õ◊ù ◊ê◊™ ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊ú◊û◊©◊™◊û◊©? (◊§◊¢◊ï◊ú◊™ "text")
- ◊î◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊ë◊ô◊ß◊© ◊ú◊î◊¢◊ë◊ô◊® ◊û◊ô◊ô◊ú ◊°◊§◊¶◊ô◊§◊ô? (◊§◊¢◊ï◊ú◊™ "forward_email_from_search" ◊¢◊ù ◊î-searchResultGmailId ◊î◊û◊™◊ê◊ô◊ù)
- ◊î◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊ë◊ô◊ß◊© ◊ú◊î◊¢◊ë◊ô◊® ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ◊°◊§◊¶◊ô◊§◊ô? (◊§◊¢◊ï◊ú◊™ "forward_attachment_from_search" ◊¢◊ù ◊î-searchResultGmailId ◊ï◊§◊®◊ò◊ô ◊î-attachmentInfo ◊î◊û◊™◊ê◊ô◊û◊ô◊ù)
- ◊î◊ê◊ù ◊ú◊©◊ê◊ï◊ú ◊ê◊™ ◊î◊û◊©◊™◊û◊© ◊û◊î ◊î◊ï◊ê ◊®◊ï◊¶◊î ◊ú◊¢◊©◊ï◊™ ◊¢◊ù ◊î◊™◊ï◊¶◊ê◊ï◊™? (◊§◊¢◊ï◊ú◊™ "text")
- ◊ï◊ì◊ê ◊©◊î◊©◊ì◊î "replyToTelegramMessageId" ◊ë◊™◊í◊ï◊ë◊™◊ö ◊ô◊î◊ô◊î ◊î◊û◊ñ◊î◊î ◊©◊ú *◊î◊î◊ï◊ì◊¢◊î ◊î◊û◊ß◊ï◊®◊ô◊™* ◊©◊ú ◊î◊û◊©◊™◊û◊©: ${originalMsg.message_id}.

◊¶◊ï◊® ◊™◊í◊ï◊ë◊™ JSON ◊™◊ß◊†◊ô◊™ ◊¢◊ù ◊î◊§◊¢◊ï◊ú◊î ◊î◊ë◊ê◊î.
◊™◊í◊ï◊ë◊™ JSON:
`;
            console.log("\n===================== Gemini Follow-up Prompt Start =====================");
            // console.log(followUpPrompt); // Usually too long
            console.log(`Follow-up Prompt length: ${followUpPrompt.length} chars`);
            console.log("====================== Gemini Follow-up Prompt End ======================\n");

            try {
                 const jsonFollowUpResponse = await callGemini(followUpPrompt);

                 // Handle potential multiple actions from follow-up
                 if (jsonFollowUpResponse.replies && Array.isArray(jsonFollowUpResponse.replies)) {
                     console.log(`‚ö° Received ${jsonFollowUpResponse.replies.length} follow-up actions from Gemini.`);
                     for (const actionDataFollowUp of jsonFollowUpResponse.replies) {
                         if (!actionDataFollowUp || !actionDataFollowUp.replyToTelegramMessageId) {
                             console.warn("‚ö†Ô∏è Skipping follow-up action in 'replies' array due to missing data or replyToTelegramMessageId:", actionDataFollowUp);
                             continue;
                         }
                         // Pass the *same* search results context again
                         await handleGeminiAction(actionDataFollowUp, originalMsg, recentSearchResults[chatId]);
                         await delay(600);
                     }
                 } else {
                      // Handle single follow-up action
                      if (!jsonFollowUpResponse || !jsonFollowUpResponse.replyToTelegramMessageId) {
                           console.warn("‚ö†Ô∏è Gemini follow-up response is missing replyToTelegramMessageId. Using fallback.", jsonFollowUpResponse);
                           jsonFollowUpResponse.replyToTelegramMessageId = originalMsg.message_id;
                       }
                       // Pass the *same* search results context again
                     await handleGeminiAction(jsonFollowUpResponse, originalMsg, recentSearchResults[chatId]);
                 }

             } catch (geminiFollowUpError) {
                 console.error("‚ùå Error calling Gemini for follow-up after search:", geminiFollowUpError);
                 await sendMessageAndLog(chatId, `‚ö†Ô∏è ◊°◊ú◊ô◊ó◊î, ◊û◊¶◊ê◊™◊ô ◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ö ◊†◊™◊ß◊ú◊™◊ô ◊ë◊©◊í◊ô◊ê◊î ◊ë◊¢◊ô◊ë◊ï◊ì◊ü.\n◊§◊®◊ò◊ô◊ù: ${geminiFollowUpError.message}`, { reply_to_message_id: originalMsg.message_id });
             }
        }

    } catch (error) {
        console.error("‚ùå Failed to perform Gmail search:", error.response?.data?.error?.message || error.message);
        throw new Error(`◊©◊í◊ô◊ê◊î ◊ë◊ó◊ô◊§◊ï◊© ◊û◊ô◊ô◊ú◊ô◊ù: ${error.response?.data?.error?.message || error.message}`);
    }
}

// --- *** NEW: Forward Email from Search Handler *** ---
async function handleForwardEmailFromSearchAction(actionData, originalMsg, currentSearchResults) {
    const chatId = originalMsg.chat.id;
    const replyToTelegramId = actionData.replyToTelegramMessageId || originalMsg.message_id;
    const gmailIdToForward = actionData.searchResultGmailId;

    if (!gmailIdToForward) {
        throw new Error("◊ô◊© ◊ú◊¶◊ô◊ô◊ü ◊ê◊™ ◊û◊ñ◊î◊î ◊î◊ì◊ï◊ê\"◊ú ◊û◊î◊ó◊ô◊§◊ï◊© ('searchResultGmailId') ◊ú◊î◊¢◊ë◊®◊î.");
    }

    // Optional: Validate if the ID exists in the recent search results for this chat
     const foundInRecent = currentSearchResults?.results?.find(r => r.id === gmailIdToForward);
     if (!foundInRecent) {
         console.warn(`‚ö†Ô∏è Gmail ID ${gmailIdToForward} requested for forwarding not found in recent search results for chat ${chatId}. Proceeding anyway.`);
         // Consider throwing an error or confirming with user if strict validation is needed
         // throw new Error(`◊û◊ñ◊î◊î ◊î◊ì◊ï◊ê"◊ú '${gmailIdToForward}' ◊ú◊ê ◊†◊û◊¶◊ê ◊ë◊™◊ï◊¶◊ê◊ï◊™ ◊î◊ó◊ô◊§◊ï◊© ◊î◊ê◊ó◊®◊ï◊†◊ï◊™.`);
     }

    console.log(`üì¨ Handling forward_email_from_search: GmailID=${gmailIdToForward}`);

    try {
        // Fetch full message details (again, might be cached but safer to fetch)
        const msg = await gmail.users.messages.get({
            userId: 'me',
            id: gmailIdToForward,
            format: 'full' // Need full format for body
        });

        const payload = msg.data.payload;
        if (!payload) throw new Error("◊ú◊ê ◊†◊û◊¶◊ê ◊™◊ï◊õ◊ü (payload) ◊ë◊î◊ï◊ì◊¢◊î.");
        const headers = payload.headers || [];

        const subject = headers.find(h => h.name.toLowerCase() === 'subject')?.value || 'No Subject';
        const from = headers.find(h => h.name.toLowerCase() === 'from')?.value || 'Unknown Sender';
        const dateHeader = headers.find(h => h.name.toLowerCase() === 'date')?.value;
        const date = dateHeader ? moment(dateHeader).tz(ISRAEL_TIMEZONE).format('DD/MM/YYYY HH:mm') : 'Unknown Date';

        let body = extractTextBody(payload); // Prefer plain text
        if (!body) {
             let htmlBody = extractHtmlBody(payload);
             if (htmlBody) {
                 body = `(◊™◊¶◊ï◊í◊î ◊§◊©◊ï◊ò◊î ◊©◊ú ◊™◊ï◊õ◊ü HTML):\n${stripHtmlTags(htmlBody).substring(0, 3500)}...`;
             } else {
                 body = '(◊ú◊ê ◊†◊û◊¶◊ê ◊í◊ï◊£ ◊î◊ï◊ì◊¢◊î)';
             }
        }

         // Prepare Telegram message for the forwarded email
         let forwardMessage = ` Forwarded Email (ID: \`${gmailIdToForward}\`) \n\n`; // English title? Or Hebrew? Let's keep it simple.
         forwardMessage = `üìß *◊î◊ï◊ì◊¢◊™ ◊ì◊ï◊ê"◊ú ◊û◊ï◊¢◊ë◊®◊™ (◊û◊ñ◊î◊î: \`${gmailIdToForward}\`)* üìß\n\n`;
         forwardMessage += `*◊û◊ê◊™:* \`${from}\`\n`;
         forwardMessage += `*◊†◊ï◊©◊ê:* ${subject}\n`;
         forwardMessage += `*◊™◊ê◊®◊ô◊ö:* ${date}\n`;
         forwardMessage += `------------------\n`;
         forwardMessage += body.substring(0, 3800); // Slightly larger limit for forwarded content
         if (body.length > 3800) {
             forwardMessage += "\n\n_[◊î◊ï◊ì◊¢◊î ◊ß◊ï◊¶◊®◊î]_";
         }

         // List attachments if any
         const attachments = findAttachments(payload);
         if (attachments.length > 0) {
             forwardMessage += `\n\nüìé *◊ß◊ë◊¶◊ô◊ù ◊û◊¶◊ï◊®◊§◊ô◊ù ◊ß◊ô◊ô◊û◊ô◊ù (◊ú◊ê ◊î◊ï◊¢◊ë◊®◊ï ◊ê◊ï◊ò◊ï◊û◊ò◊ô◊™):*\n`;
             attachments.forEach(att => {
                 forwardMessage += `- ${att.filename} (${formatBytes(att.size)})\n`;
             });
             forwardMessage += `_(◊†◊ô◊™◊ü ◊ú◊ë◊ß◊© ◊î◊¢◊ë◊®◊™ ◊ß◊ï◊ë◊• ◊°◊§◊¶◊ô◊§◊ô ◊ë◊†◊§◊®◊ì)_`;
         }

         console.log(`‚úÖ Forwarding email content for ID: ${gmailIdToForward}`);
         // Split message if too long
          const messageChunks = splitMessage(forwardMessage, 4000);
          for (const chunk of messageChunks) {
              await sendMessageAndLog(chatId, chunk, { parse_mode: 'Markdown', reply_to_message_id: replyToTelegramId });
              await delay(300);
          }

         // Send SUCCESS confirmation (already sent via loop above)
         // await sendMessageAndLog(chatId, `‚úÖ ◊™◊ï◊õ◊ü ◊î◊û◊ô◊ô◊ú (ID: ${gmailIdToForward}) ◊î◊ï◊¢◊ë◊®.`, { reply_to_message_id: replyToTelegramId });

    } catch (error) {
        console.error(`‚ùå Failed to forward email content (ID: ${gmailIdToForward}):`, error.response?.data || error.message);
        throw new Error(`◊©◊í◊ô◊ê◊î ◊ë◊î◊¢◊ë◊®◊™ ◊™◊ï◊õ◊ü ◊î◊û◊ô◊ô◊ú: ${error.message}`);
    }
}

// --- *** NEW: Forward Attachment from Search Handler *** ---
async function handleForwardAttachmentFromSearchAction(actionData, originalMsg, currentSearchResults) {
    const chatId = originalMsg.chat.id;
    const replyToTelegramId = actionData.replyToTelegramMessageId || originalMsg.message_id;
    const gmailId = actionData.searchResultGmailId;
    const attachmentInfo = actionData.attachmentInfo;

    if (!gmailId || !attachmentInfo || !attachmentInfo.filename || (!attachmentInfo.partId && !attachmentInfo.attachmentId)) {
        throw new Error("◊ô◊© ◊ú◊¶◊ô◊ô◊ü ◊û◊ñ◊î◊î ◊ì◊ï◊ê\"◊ú ('searchResultGmailId') ◊ï◊§◊®◊ò◊ô ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ('attachmentInfo' ◊¢◊ù filename ◊ï-partId ◊ê◊ï attachmentId) ◊ú◊î◊¢◊ë◊®◊™ ◊ß◊ï◊ë◊•.");
    }

    // Extract necessary IDs
    const filename = attachmentInfo.filename;
    const partId = attachmentInfo.partId; // May not always be present
    const attachmentId = attachmentInfo.attachmentId; // Often present for non-inline

    if (!attachmentId) {
         // If no attachmentId, we MUST have partId to fetch via messages.get
         if (!partId) {
             throw new Error(`◊ú◊ê ◊°◊ï◊§◊ß ◊û◊ñ◊î◊î ('attachmentId' ◊ê◊ï 'partId') ◊¢◊ë◊ï◊® ◊î◊ß◊ï◊ë◊• '${filename}'.`);
         }
         console.warn(`‚ö†Ô∏è Attachment ID missing for '${filename}', attempting fetch using Part ID: ${partId}. This might fail for some attachments.`);
         // Proceeding with partId method below
    }


    console.log(`üìé Handling forward_attachment_from_search: GmailID=${gmailId}, Filename=${filename}, AttID=${attachmentId}, PartID=${partId}`);

    let tempFilePath = null; // To ensure cleanup

    try {
        let attachmentData;

        // Prefer fetching using attachmentId if available (more direct)
        if (attachmentId) {
            try {
                 console.log(`Fetching attachment using attachmentId: ${attachmentId}`);
                 const response = await gmail.users.messages.attachments.get({
                    userId: 'me',
                    messageId: gmailId,
                    id: attachmentId
                });
                if (!response.data || !response.data.data) {
                    throw new Error(`◊™◊í◊ï◊ë◊î ◊®◊ô◊ß◊î ◊ë◊¢◊™ ◊ß◊ë◊ú◊™ ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ◊¢◊ù attachmentId ${attachmentId}`);
                }
                attachmentData = response.data.data;
             } catch(attachError) {
                 console.error(`‚ùå Error fetching attachment using attachmentId ${attachmentId}: ${attachError.message}. Trying with partId if available.`);
                 // Fallback to partId method if attachmentId fetch fails and partId exists
                 if (!partId) throw attachError; // Re-throw if no partId fallback
                  else console.log("Trying fallback using partId...");
                  // Clear attachmentData to trigger the partId block below
                  attachmentData = null;
             }
        }


        // Fetch using messages.get and partId if attachmentId wasn't available or failed
        if (!attachmentData && partId) {
            console.log(`Fetching attachment using partId: ${partId}`);
            const msg = await gmail.users.messages.get({
                userId: 'me',
                id: gmailId,
                format: 'full' // Need full payload
            });
            const part = findPartById(msg.data.payload, partId);
            if (!part || !part.body || !part.body.attachmentId) {
                console.error("Payload structure:", JSON.stringify(msg.data.payload, null, 2).substring(0, 1000)); // Log relevant part structure
                throw new Error(`◊ú◊ê ◊†◊û◊¶◊ê ◊ó◊ú◊ß (part) ◊¢◊ù ◊û◊ñ◊î◊î ${partId} ◊ê◊ï ◊©◊ó◊°◊® ◊ú◊ï attachmentId ◊ë◊í◊ï◊£ ◊î◊î◊ï◊ì◊¢◊î ${gmailId}.`);
            }
            // Now get the attachment using the attachmentId found in the part
            const actualAttachmentId = part.body.attachmentId;
            console.log(`Found attachmentId ${actualAttachmentId} within part ${partId}. Fetching...`);
             const response = await gmail.users.messages.attachments.get({
                 userId: 'me',
                 messageId: gmailId,
                 id: actualAttachmentId
             });
             if (!response.data || !response.data.data) {
                    throw new Error(`◊™◊í◊ï◊ë◊î ◊®◊ô◊ß◊î ◊ë◊¢◊™ ◊ß◊ë◊ú◊™ ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ◊¢◊ù attachmentId ${actualAttachmentId} (◊ì◊®◊ö partId ${partId})`);
             }
            attachmentData = response.data.data;
        } else if (!attachmentData && !partId) {
             // This case should be caught earlier, but as a safeguard
             throw new Error("◊ú◊ê ◊°◊ï◊§◊ß ◊û◊ñ◊î◊î (attachmentId ◊ê◊ï partId) ◊™◊ß◊ô◊ü ◊ú◊ê◊ô◊™◊ï◊® ◊î◊ß◊ï◊ë◊•.");
         }


        // Decode Base64 data (handle URL-safe variant)
        const decodedData = Buffer.from(attachmentData.replace(/-/g, '+').replace(/_/g, '/'), 'base64');

        // Save to temporary file
        fs.mkdirSync(TEMP_FILES_DIR, { recursive: true }); // Ensure dir exists
        // Use a unique name to avoid collisions, but keep original extension
        const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, '_'); // Sanitize
        tempFilePath = path.join(TEMP_FILES_DIR, `${Date.now()}_${safeFilename}`);
        fs.writeFileSync(tempFilePath, decodedData);
        console.log(`üíæ Saved attachment to temporary file: ${tempFilePath}`);

        // Send the file via Telegram
        console.log(`üì≤ Sending attachment '${filename}' to Telegram...`);
        await bot.sendDocument(chatId, tempFilePath, {
            caption: `üìÑ ◊ß◊ï◊ë◊• ◊û◊¶◊ï◊®◊£ ◊û◊î◊û◊ô◊ô◊ú (ID: \`${gmailId}\`)\n◊©◊ù ◊ß◊ï◊ë◊•: ${filename}`,
            reply_to_message_id: replyToTelegramId
        }, {
             filename: filename, // Pass original filename for display
             contentType: mime.lookup(filename) || 'application/octet-stream'
        });

        console.log(`‚úÖ Attachment '${filename}' sent successfully.`);

        // Send SUCCESS confirmation (already implied by file send)
        // await sendMessageAndLog(chatId, `‚úÖ ◊î◊ß◊ï◊ë◊• '${filename}' ◊û◊î◊û◊ô◊ô◊ú (ID: ${gmailId}) ◊î◊ï◊¢◊ë◊®.`, { reply_to_message_id: replyToTelegramId });

    } catch (error) {
        console.error(`‚ùå Failed to forward attachment (GmailID: ${gmailId}, File: ${filename}):`, error.response?.data || error.message);
        // Try to send an error message to the user
        await sendMessageAndLog(chatId, `‚ö†Ô∏è ◊°◊ú◊ô◊ó◊î, ◊ß◊®◊™◊î ◊©◊í◊ô◊ê◊î ◊ë◊¢◊™ ◊†◊ô◊°◊ô◊ï◊ü ◊ú◊î◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊ß◊ï◊ë◊• '${filename}'.\n◊§◊®◊ò◊ô◊ù: ${error.message}`, { reply_to_message_id: replyToTelegramId });
        // Don't re-throw, error is reported.
    } finally {
        // Clean up the temporary file regardless of success or failure
        if (tempFilePath && fs.existsSync(tempFilePath)) {
            cleanupTemporaryFile(tempFilePath, null); // No telegram ID associated here
        }
    }
}


// --- Chat History and Context Management ---

function addToHistory(chatId, msg) {
    if (!chatHistory[chatId]) {
        chatHistory[chatId] = [];
    }
    const history = chatHistory[chatId];

     let senderPrefix = `User_${msg.from?.id || 'Unknown'}`;
     if (msg.from?.is_bot && msg.from?.id === botInfo?.id) {
         senderPrefix = "◊ê◊†◊ô (◊î◊ë◊ï◊ò)";
     } else if (msg.from?.is_bot && msg.from?.first_name === 'System') { // Handle System messages
          senderPrefix = "[System]";
     } else if (msg.from) {
         senderPrefix = msg.from.first_name || msg.from.username || senderPrefix;
     }

     let messageText = msg.text || '';
     if (msg.caption) messageText += ` [◊õ◊ô◊™◊ï◊ë: ${msg.caption}]`;
     if (msg.document) messageText += ` [◊û◊°◊û◊ö: ${msg.document.file_name || '◊ß◊ï◊ë◊•'}]`;
     else if (msg.photo) messageText += ` [◊™◊û◊ï◊†◊î]`;
     else if (msg.audio) messageText += ` [◊©◊û◊¢]`;
     else if (msg.video) messageText += ` [◊ï◊ô◊ì◊ê◊ï]`;
     else if (msg.voice) messageText += ` [◊î◊ï◊ì◊¢◊î ◊ß◊ï◊ú◊ô◊™]`;
     else if (msg.sticker) messageText += ` [◊°◊ò◊ô◊ß◊®: ${msg.sticker.emoji || 'sticker'}]`;
     if (messageText.trim() === '') messageText = '[◊™◊ï◊õ◊ü ◊ú◊ê ◊ò◊ß◊°◊ò◊ï◊ê◊ú◊ô ◊ê◊ï ◊î◊ï◊ì◊¢◊î ◊®◊ô◊ß◊î]';

    const messageEntry = {
        id: msg.message_id,
        sender: senderPrefix,
        text: messageText,
        timestamp: (msg.date || Math.floor(Date.now() / 1000)) * 1000
    };

    history.push(messageEntry);
    if (history.length > HISTORY_LENGTH) {
        history.shift();
    }
    chatHistory[chatId] = history;
}


function getChatHistory(chatId) {
    const history = chatHistory[chatId] || [];
    if (history.length === 0) return "◊ê◊ô◊ü ◊î◊ô◊°◊ò◊ï◊®◊ô◊ô◊™ ◊©◊ô◊ó◊î.";
    return history.map(entry => `${entry.sender} (ID:${entry.id}): ${entry.text}`).join('\n');
}

function formatMemoriesForPrompt() {
     if (!memories || memories.length === 0) return "◊ê◊ô◊ü ◊ñ◊ô◊õ◊®◊ï◊†◊ï◊™ ◊©◊û◊ï◊®◊ô◊ù.";
    return memories.slice(0, 20) // Limit memories in prompt
        .map(mem => `${mem.id} | ${moment(mem.timestamp).format('DD/MM/YY HH:mm')} | ${mem.person || '◊õ◊ú◊ú◊ô'}: ${mem.info}`)
        .join('\n');
}

// *** NEW: Format Search Results for Prompt ***
function formatSearchResultsForPrompt(chatId) {
    const searchData = recentSearchResults[chatId];
    if (!searchData || !searchData.results || searchData.results.length === 0) {
        return "◊ê◊ô◊ü ◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ó◊®◊ï◊†◊ï◊™.";
    }

    let formatted = `--- ◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ◊ê◊ó◊®◊ï◊†◊ï◊™ (◊©◊ê◊ô◊ú◊™◊î: "${searchData.query || ''}" ${searchData.searchPeriod || ''}) ---\n`;
    searchData.results.forEach((res, index) => {
        formatted += `[${index + 1}] ID: ${res.id} | ◊™◊ê◊®◊ô◊ö: ${res.date} | ◊û◊ê◊™: ${res.from} | ◊†◊ï◊©◊ê: ${res.subject}\n`;
        formatted += `    ◊™◊ß◊¶◊ô◊®: ${res.snippet}\n`;
        if (res.attachments.length > 0) {
            formatted += `    ◊ß◊ë◊¶◊ô◊ù ◊û◊¶◊ï◊®◊§◊ô◊ù:\n`;
            res.attachments.forEach((att, attIndex) => {
                 // CRUCIAL: Provide the necessary info for the AI to use forward_attachment_from_search
                formatted += `      - ${attIndex+1}: ${att.filename} (partId: ${att.partId || 'N/A'}, attachmentId: ${att.attachmentId || 'N/A'})\n`;
            });
        }
    });
     formatted += `--- ◊°◊ï◊£ ◊™◊ï◊¶◊ê◊ï◊™ ◊ó◊ô◊§◊ï◊© ---`;
    return formatted;
}

// --- Utility Functions ---
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function stripHtmlTags(html) {
    if (!html) return '';
    let text = html.replace(/<style([\s\S]*?)<\/style>/gi, '');
    text = text.replace(/<script([\s\S]*?)<\/script>/gi, '');
    text = text.replace(/<[^>]*>/g, ' ');
    text = text.replace(/&nbsp;/gi, ' ');
    text = text.replace(/&lt;/gi, '<');
    text = text.replace(/&gt;/gi, '>');
    text = text.replace(/&amp;/gi, '&');
    text = text.replace(/&quot;/gi, '"');
    text = text.replace(/&apos;/gi, "'");
    text = text.replace(/\s+/g, ' ').trim();
    return text;
}

function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

function cleanupTemporaryFile(filePath, telegramMessageId = null) {
    try {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            console.log(`üßπ Cleaned up temporary file: ${filePath}`);
        }
        if (telegramMessageId !== null) {
            telegramFileMap.delete(telegramMessageId); // Remove from map if associated with Telegram msg
            console.log(`üó∫Ô∏è Removed file mapping for Telegram message ID: ${telegramMessageId}`);
        }
    } catch (cleanupError) {
        console.error(`‚ö†Ô∏è Error cleaning up file ${filePath}:`, cleanupError);
    }
}

// Helper to find attachments within payload parts recursively
function findAttachments(payload) {
    let attachments = [];
    const parts = payload.parts || [];

    for (const part of parts) {
        if (part.filename && part.filename.length > 0 && part.body?.attachmentId) {
             // This is likely a standard attachment
            attachments.push({
                filename: part.filename,
                mimeType: part.mimeType || 'application/octet-stream',
                size: part.body.size || 0,
                partId: part.partId, // Include partId
                attachmentId: part.body.attachmentId // Include attachmentId
            });
        } else if (part.parts) {
            // Recursively search in nested parts
            attachments = attachments.concat(findAttachments(part));
        } else if (payload.mimeType?.startsWith('multipart/') && !part.parts && part.filename && part.body?.size > 0){
             // Handle cases where the main payload is multipart but parts lack detail,
             // yet individual parts *might* be attachments (e.g., inline images without attachmentId but with filename)
             // This heuristic might need refinement.
              if(part.body?.attachmentId){ // Prefer parts with attachmentId
                  attachments.push({
                      filename: part.filename,
                      mimeType: part.mimeType || 'application/octet-stream',
                      size: part.body.size || 0,
                      partId: part.partId,
                      attachmentId: part.body.attachmentId
                  });
              } else {
                   // Consider logging or handling parts without attachmentId differently if needed
                   // console.log(`Part ${part.partId} has filename but no attachmentId, potential inline?`)
              }
        }
    }
    return attachments;
}

// Helper to find a specific part by its ID recursively
function findPartById(payload, partIdToFind) {
     if (payload.partId === partIdToFind) {
         return payload;
     }
     if (payload.parts) {
         for (const part of payload.parts) {
             const found = findPartById(part, partIdToFind);
             if (found) {
                 return found;
             }
         }
     }
     return null; // Not found
}


// Helper to extract plain text body recursively
function extractTextBody(payload) {
    if (payload.mimeType === 'text/plain' && payload.body?.data) {
        return Buffer.from(payload.body.data, 'base64').toString('utf8');
    }
    if (payload.parts) {
        for (const part of payload.parts) {
             if (part.mimeType === 'text/plain' && part.body?.data) {
                 return Buffer.from(part.body.data, 'base64').toString('utf8');
             } else if (part.mimeType?.startsWith('multipart/')) {
                 const nestedBody = extractTextBody(part); // Recurse
                 if (nestedBody) return nestedBody;
             }
        }
    }
    // If no direct text/plain found, check the top level if it wasn't multipart
     if (payload.body?.data && !payload.parts && payload.mimeType !== 'text/html') { // Basic fallback
         // This might grab non-text data if mimeType is wrong, use cautiously
         // return Buffer.from(payload.body.data, 'base64').toString('utf8');
     }
    return null;
}
// Helper to extract HTML body recursively
function extractHtmlBody(payload) {
    if (payload.mimeType === 'text/html' && payload.body?.data) {
        return Buffer.from(payload.body.data, 'base64').toString('utf8');
    }
     if (payload.parts) {
         for (const part of payload.parts) {
             if (part.mimeType === 'text/html' && part.body?.data) {
                 return Buffer.from(part.body.data, 'base64').toString('utf8');
             } else if (part.mimeType?.startsWith('multipart/')) {
                 const nestedBody = extractHtmlBody(part); // Recurse
                 if (nestedBody) return nestedBody;
             }
         }
     }
    return null;
}


// *** NEW: Helper to build Gmail query string ***
function buildGmailQuery(query, searchPeriod) {
    let qParts = [];
    if (query && query.trim().length > 0) {
        qParts.push(`(${query.trim()})`); // Wrap main query in parentheses
    }

    if (searchPeriod) {
        const now = moment();
        let afterDate = null;
        let beforeDate = null;
         const periodLower = searchPeriod.toLowerCase();

        if (periodLower === 'today') {
            afterDate = now.startOf('day');
            beforeDate = now.endOf('day');
        } else if (periodLower === 'yesterday') {
            afterDate = now.subtract(1, 'day').startOf('day');
            beforeDate = now.endOf('day'); // Yesterday ends at the start of today
        } else if (periodLower.startsWith('last_')) {
             const match = periodLower.match(/^last_(\d+)_days$/);
             if (match && match[1]) {
                 const days = parseInt(match[1], 10);
                 if (!isNaN(days) && days > 0) {
                     afterDate = now.subtract(days, 'days').startOf('day');
                     beforeDate = moment().endOf('day'); // Use moment() for current end of day
                 }
             }
        } else if (/^\d{4}-\d{2}-\d{2}$/.test(searchPeriod)) {
             // Specific date YYYY-MM-DD
             const specificDate = moment(searchPeriod, 'YYYY-MM-DD');
             if (specificDate.isValid()) {
                 afterDate = specificDate.startOf('day');
                 beforeDate = specificDate.endOf('day');
             }
        } else {
             // Check for after:YYYY-MM-DD before:YYYY-MM-DD syntax
             const afterMatch = searchPeriod.match(/after:(\d{4}-\d{2}-\d{2})/);
             const beforeMatch = searchPeriod.match(/before:(\d{4}-\d{2}-\d{2})/);
             if (afterMatch && afterMatch[1]) {
                 const parsedAfter = moment(afterMatch[1], 'YYYY-MM-DD');
                 if(parsedAfter.isValid()) afterDate = parsedAfter.startOf('day');
             }
             if (beforeMatch && beforeMatch[1]) {
                  const parsedBefore = moment(beforeMatch[1], 'YYYY-MM-DD');
                  // Gmail 'before:' is exclusive, so use the start of that day
                  if(parsedBefore.isValid()) beforeDate = parsedBefore.startOf('day');
             }
        }

        // Format for Gmail query (YYYY/MM/DD)
        if (afterDate) {
            qParts.push(`after:${afterDate.format('YYYY/MM/DD')}`);
        }
        if (beforeDate) {
             // Gmail 'before' is exclusive, so if we want to include the 'beforeDate',
             // we actually need to set the 'before' to the *next* day.
             // Exception: if afterDate and beforeDate are the same day (e.g., 'today' or specific date)
             if (afterDate && beforeDate.isSame(afterDate, 'day')) {
                  qParts.push(`before:${beforeDate.add(1, 'day').format('YYYY/MM/DD')}`);
             } else {
                  qParts.push(`before:${beforeDate.format('YYYY/MM/DD')}`);
             }
        }
    }

    return qParts.join(' '); // Combine parts with spaces
}


// Helper to split long messages for Telegram
function splitMessage(text, maxLength = 4096) {
     const chunks = [];
     let currentChunk = '';

     // Split by lines first
     const lines = text.split('\n');

     for (const line of lines) {
         // If adding the next line exceeds max length
         if (currentChunk.length + line.length + 1 > maxLength) {
             // If the current chunk is not empty, push it
             if (currentChunk.length > 0) {
                 chunks.push(currentChunk);
             }
             // Start a new chunk with the current line
             currentChunk = line;
             // Handle case where a single line itself is too long
             while (currentChunk.length > maxLength) {
                 chunks.push(currentChunk.substring(0, maxLength));
                 currentChunk = currentChunk.substring(maxLength);
             }
         } else {
             // Add line to current chunk
             if (currentChunk.length > 0) {
                 currentChunk += '\n' + line;
             } else {
                 currentChunk = line;
             }
         }
     }

     // Push the last remaining chunk
     if (currentChunk.length > 0) {
         chunks.push(currentChunk);
     }

     return chunks;
 }


// --- Start the Bot ---
// initialize().catch(err => {
//     console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
//     console.error("!!! BOT FAILED TO INITIALIZE !!!", err);
//     console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
//     process.exit(1);
// });

// --- HTTP Server Setup (ADD THIS SECTION) ---
function setupHttpServer() {
    const app = express();
    const PORT = process.env.PORT || 3000;

    app.use(cors()); // Enable CORS for all routes - good for local dev
    app.use(express.json()); // Middleware to parse JSON bodies

    // Mount the admin API routes
    app.use('/api/admins', adminApiRoutes);

    app.get('/', (req, res) => {
        res.send('Telegram Bot and Admin API are running.');
    });

    app.listen(PORT, () => {
        console.log(`üöÄ HTTP Admin API server running on port ${PORT}`);
    });

    return app; // Return app if needed elsewhere, though not strictly for this setup
}

// --- Modify how initialize is called ---
// Original: initialize().catch(...)
// New:
async function startApp() {
    await initialize(); // Initialize the bot
    setupHttpServer(); // Setup and start the HTTP server
}

startApp().catch(err => {
    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    console.error("!!! APP FAILED TO START (BOT OR HTTP SERVER) !!!", err);
    console.error("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    process.exit(1);
});